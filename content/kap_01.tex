\chapter{Einleitung}
\section{Warum theoretische Informatik?}
Warum lohnt sich die Beschäftigung mit theoretischer Informatik?
Die kurze Antwort: Sie liefert einen Teil des nötigen Handwerkszeug,
um die Potentiale und Grenzen der technischen Informationsverarbeitung zu umreißen.
Die lange Antwort soll dieses Skript geben.

Das Skript wurde begleitend zur Veranstaltung ''Theoretische Informatik für Wirtschaftsinformatiker''
an der DHBW Heilbronn erstellt.
Wir folgen in diesem Skript einem kartesischen Ansatz:
Wir gehen vom maximalen Zweifel aus und setzen die theoretische Informatik 
als potentiellen Nichtsnutz auf die Anklagebank.
Schritt für Schritt werden wir die Jury (die Studierenden) von der Unschuld dieser
Disiplin überzeugen.
Wir beginnen mit der Feststellung, dass uns als Informatiker:innen die Nützlichkeit
eines Werkzeugs dann einleuchtet, wenn es hilft Probleme zu lösen. 
Daher ist der Problembegriff im Mittelpunkt dieses Skripts.

Was also ist ein Problem?
Bevor wir diese Frage grundlegend beantworten können,
ist es hilfreich ein paar Probleme kennen zu lernen,
wie sie im IT-Alltag auftreten können.

\section{Probleme}
Wir werden nun ein paar alltägliche Probleme als Userstories wiedergeben.
Eine Userstory wird in der agilen Softwareentwicklung genutzt um Anforderungen zu spezfizieren.
Es folgt typischerweise diesem Format:
''Als \textless Rolle\textgreater\ möchte ich \textless Feature\textgreater,
um \textless Ziel\textgreater\ zu erreichen.''

\begin{itemize}
    \item \textbf{MAX}: Als Filialleiterin möchte ich das Produkt kennen,
        dass sich am besten verkauft, um meine Lieferungen zu optimieren.
    \item \textbf{MATCH}: Als Einkaufsmanager möchte ich,
        dass nur valide Lieferanten-IDs gespeichert werden,
        um Fehler in der Datenbank zu vermeiden.
    \item \textbf{HALT}: Als Product Owner des Serverless-Computings möchte ich,
        dass nur terminierende Code-Snippets deployt werden,
        um die verfügbaren Ressourcen effizient zu nutzen.
    \item \textbf{ROUTE}: Als Kommissioniererin möchte ich,
        dass morgens die optimalen Routen für die LKWs in die 24 Filialen berechnet werden,
        um die Lieferzeit zu minimieren.
    \item \textbf{QUANTUMSEC}: Als Chief Security Officer möchte ich,
        dass die firmen-interne Kommunikation quantensicher verschlüsselt wird,
        um die Vertraulichkeit der Absprachen zu garantieren.
\end{itemize}

Alle Probleme treten in einer Form auf,
wie sie viele IT-Angestellten täglich vorfinden, dann analysieren und schließlich lösen müssen.
Die theoretische Informatik kann auch einiges über diese Probleme sagen:
\begin{itemize}
    \item Mindestens ein Problem ist sehr schwer zu lösen.
    \item Mindestens ein Problem ist sehr einfach zu lösen.
    \item Mindestens ein Problem ist nicht lösbar. 
    \item Bei mindestens einem Problem ist unklar, ob es sich lösen lässt.
\end{itemize}

Am Ende dieses Skriptes soll klar sein, welches dieser Probleme in welche dieser Kategorien fällt.
An diesem Punkt im Text wollen wir uns aber zunächst damit begnügen,
dass ein Fach Nutzen bringt, dass es erlaubt, diese Probleme auf einen Blick als leicht oder
schwer, unlösbar oder von unbekannter Komplexität zu kategorisieren. 

\section{Abstraktion}

Um die Probleme aus dem vorigen Absatz für die Bearbeitung mit den Werkzeugen der
theoretischen Informatik vorzubereiten ist noch etwas an Arbeit notwendig.
Ein grundlegendes Instrument nicht nur der theoretischen Informatik, sondern der Informatik
überhaupt ist die Abstraktion, also die ausschließliche Betrachtung der Aspekte eines Sachverhalts,
die für die Lösung eines Problems wesentlich sind.

So ist z.B. auf den ersten Blick unwesentlich, ob im \textbf{ROUTE}-Problem 2, 24 oder 100 Filialen angefahren werden,
ob es überhaupt Filialen sind (und nicht Lager, Tankstellen, oder Adressen von Kund:innen),
oder ob die Strecke morgens oder abends,
mit LKWs oder Kleintransportern befahren werden.
Viele dieser Details scheinen für die algorithmische Behandlung des Problems irrelevant.

Der Kern des Problems liegt in einer abstrakten Datenstruktur:
ein Graph dessen Knoten mit einer Kostenfunktion verbunden sind:
Die Knoten des Graphen sind die Filialen (oder Lager, ...),
die Kostenfunktion auf den Kanten ist die Dauer der Fahrt zwischen den Filialen (oder der Benzinverbrauch, die Distanz, ...).
Wir kommen mit Hilfe der Abstraktion also auf eine neue Formulierung des Problems:
\begin{itemize}
    \item \textbf{Gegeben:} Ein Graph mit einer Kostenfunktion
    \item \textbf{Gesucht:} Die Folge von einer Teilmenge der Knoten, für die die Kostenfunktion minimal ist.
\end{itemize}

Der Vorgang der Abstraktion ist leider weder eindeutig noch trivial.
Es ist zum Beispiel durchaus möglich,
dass der Zeitpunkt der Fahrten eben \emph{nicht} irrelevant ist,
da die gewählte Kostenfunktion (Dauer der Fahrt)
stark von der Verkehrssituation abhängt,
die wiederum abhängig von der Tageszeit ist.
Es gibt daher nicht einen eindeutig ''richtigen'' Weg von einer Userstory zu einem abstrakten Problem zu kommen,
wie es mit den Mitteln der theoretischen Informatik behandelt werden kann.
Aber jede der möglichen Abstraktionen wird letztlich in dieser Form resultieren:
\begin{itemize}
    \item \textbf{Gegeben:} Eine oder mehrere Datenstruktur(en)
    \item \textbf{Gesucht:} Ein (potentiell komplexer) Ausgabewert
\end{itemize}
Diese Form der Problemangabe wollen wir ''informell'' nennen.

Wir halten fest, dass die Abstraktion ein Werkzeug ist,
Probleme auf ihren Kern zu reduzieren.
Diese abstrakte, informelle Form des Problems hat einen Umfang, der klein wie möglich und so groß wie nötig ist.

Allerdings haben wir das \textbf{ROUTE}-Problem noch nicht in der Form angegeben,
die nötig ist, um es mit den Werkzeugen der theoretischen Informatik zu bearbeiten.
Ganz zu schweigen von den anderen Userstories.
Software-Entwickler:innen wären mit unserem Zwischenergebnis vielleicht schon zufrieden,
denn sie wüssten, wie man ein informelles Problem in die Form ihrer Programmiersprache bringen kann.
Welche Form die theoretische Informatik verlangt, soll im nächsten Abschnitt diskutiert werden.

\section{Formalisierung}

Die Informatik ist die Wissenschaft der maschinellen Informationsverarbeitung,
daher ist es sinnvoll zu überlegen,
wie Informationen Input für eine bzw. Output von einer Maschine sein können.
Ein einfaches Modell ist die Tastatur und der Bildschirm:
Eine endliche Menge von Zeichen (die Knöpfe der Tastatur) werden übersetzt in eine
endliche Menge von Zeichen (die Pixel eines Bildschirms).
Tatsächlich werden die meisten Informationen,
die eine Maschine oder ein Computer verarbeiten,
maschinen-intern in eine sehr kleine Menge an Zeichen übersetzt:
in Zeichenfolgen bestehend auf Nullen und Einsen.

Wir kodieren also Zahlen, Videos, Bilder, Musik, Texte, im Allgemeinen alle Datenstrukturen
und Ausgabewerte als Folgen von Nullen und Einsen,
also als binäre Zeichenfolgen. 
Ebenso werden Anweisungen, was mit diesen binären Daten passieren soll,
als binäre Zeichenfolgen kodiert.
Ganz allgemein könnte man also sagen, dass alle Probleme, die ein Computer lösen soll,
sich in diese Form bringen lassen:
\begin{itemize}
    \item \textbf{Gegeben:} Eine binäre Zeichenfolge.
    \item \textbf{Gesucht:} Eine binäre Zeichenfolge.
\end{itemize}

Diese Form enstpricht einer Funktion:
bei gleicher Eingabe einer binären Zeichenfolge,
erwarten wir, dass uns die Maschine stets eine (meist von der Eingabe unterschiedliche)
gleiche binäre Zeichenfolge ausgibt.
Die Anweisung ist also rechtseindeutig (siehe \autoref{relationenUndFunktionen}).

Wie lässt sich nun aber eine Zeichenfunktion so darstellen,
dass unsere Probleme adäquat repräsentiert sind?
Damit wir dies erreichen, 
müssen wir zunächst noch einige Begriffe definieren und Konventionen einführen.

\subsection{Zeichen}

Eine Menge von Zeichen bezeichnen wir als \emph{Alphabet}, kurz: $\Sigma$.
Z.B.: $\Sigma = \{0,1\}$.\\

\noindent
Wir verwenden diese Variablen für Zeichen: $a,b,c$;
wenn wir diese Buchstaben verwenden und nichts anderes angeben,
gilt implizit: $a, b, c \in \Sigma$.\\

\noindent
Eine Operation auf den Zeichen ist die \emph{Konkatenation},
also die Verbindung von zwei oder mehreren Zeichen, z.B. $01$.

\subsection{Worte}
Das Ergebnis einer beliebig oft ausgeführten Konkatenation,
also eine (binäre) Zeichenfolge,
bezeichnen wir als \emph{Wort}, z.B.: $0101010001001001$\\

\noindent
Die Menge aller Wörter,
die sich aus einem Alphabet bilden lassen,
bezeichnen wir als \emph{Kleensche Hülle}, dargestellt als Stern: $\Sigma^*$.\\

\noindent
Wir verwenden diese Variablen für Worte:
$w, x, y, z$; wenn wir diese Buchstaben verwenden und nichts anderes angeben,
gilt implizit: $w, x, y, z \in \Sigma^*$.\\

\noindent
Die \emph{Länge} eines Wortes ist die Anzahl seiner Zeichen.
Formal benutzen wir die Betragsstriche um ein Wort, um seine
Länge zu bezeichnen. Wenn z.B. $w = 0101010001001001$, dann gilt $|w| = 16$.\\

\noindent
Das Wort mit der Länge 0, also das Wort, dass aus null Zeichen besteht,
nennen wir das \emph{leere Wort}, kurz: $\epsilon$.
Es gilt also $|\epsilon| = 0$.\\

\noindent
Für die n-malige Wiederholung eines Zeichens oder Wortes führen wir den \emph{Wiederholungsoperator}
ein, eine hochgestellte Zahl $n \in \mathbb{N}$: $a^n$ oder $w^n$.
Z.B. $0^3 = 000$ und $(10)^2 = 1010$.\\

\noindent
Wollen wir ein angeben, dass ein Zeichen oder Wort beliebig oft (also auch keinmal) wiederholt
wird, nutzen wir dafür einen hochgestellten Stern, den \emph{Kleene-Operator} $a^*$ oder $w^*$.
Mit dem Kleene-Operator bezeichnen wir immer eine unendliche Menge von Wörtern, z.B.:
$a^* = \{\epsilon, a, aa, aaa, aaaa, \dots\}$

\subsection{Formale Sprachen}

Bevor wir den Begriff der formalen Sprachen einführen, noch eine Warnung:
Während die Verwendung des Begriffs ''Zeichens''
noch recht intuitiv mit dem Begriff des Buchstaben zusammenfällt
(zumindest im deutschsprachigen Raum),  
ist schon der formal eingeführte Wort-Begriff eine kognitive Zumutung:
Worte im Sinne des vorangegangenen Abschnitts sind einfach irgendwelche Zeichenfolgen,
egal ob sie aussprechbar oder im Kontext einer natürlichen Sprache
(wie deutsch oder englisch) einen Sinn ergeben.

Man müsste also eigentlich das natursprachliche $Wort_N$ von dem formalen $Wort_F$ trennen,
das wir oben eingeführt haben.
Eine Crux aller formal arbeitenden Wissenschaften ist,
dass die Menge an Zeichen und Begriffen begrenzt ist und daher Doppeldeutigkeiten auftreten. 
Im Kontext dieses Skriptes ist ein Wort meist im formalen Sinne gemeint.
Sollte dies nicht der Fall sein und der Kontext nicht ausreichen,
um zwischen beiden Bedeutungen zu unterscheiden,
werden wir die subskribierten Varianten verwenden.

Die vorige Überlegung trifft nicht nur auf Worte, sondern auch auf \emph{Sprachen} zu.
Eine Sprache im Sinne der theoretischen Informatik ist einfach eine Menge von Worten.
Z.B. ist $L = \{0, 1, 00, 01, 10, 11 \}$ die Sprache der Worte, die aus einem oder zwei Binärzeichen bestehen.\\

\noindent
Wir verwenden $L$ mit unterschiedlichen Subskripten als Variable für Sprachen;
wenn wir $L$ verwenden und nichts Anderslautendes angeben,
gilt implizit $L \subseteq \Sigma^*$ für ein gegebenes $\Sigma$.\footnote{
Wenn $\Sigma$ nicht explizit angegeben oder aus dem Kontext herleitbar ist,
wird $\Sigma$ also auch als Variable für (irgend) ein Alphabet verwendet.}


\noindent
Da Sprachen Mengen sind,
sind alle mengentheoretischen Operationen\footnote{siehe \autoref{mengenlehre}}
auf Sprachen definiert,
z.B. $L_1 \cap L_2 = \{w | w \in L_1 \wedge w \in L_2\}$
bezeichnet die Schnittmenge zweier Sprachen, also alle Wörter,
die sowohl Element von $L_1$ als auch von $L_2$ sind.

\subsection{Probleme als Sprachen}
Wie bringt man nun die formal eingeführten Begriffe mit den eingangs vorgestellten Problem zusammen?
Wir haben diese Probleme in zwei Schritten erst abstrahiert und dann kodiert:
\begin{enumerate}
    \item \emph{Abstraktion:}
        \\\textbf{Gegeben:} Eine Datenstruktur
        \\\textbf{Gesucht:} Ein Ausgabewert
    \item \emph{Kodierung:}
        \\\textbf{Gegeben:} Eine Zeichenfolge, die eine Datenstruktur kodiert.
        \\\textbf{Gesucht:} Eine Zeichenfolge, die einen Ausgabewert kodiert.
\end{enumerate}
Der letzte Schritt ist nun das gesamte Gegeben/Gesucht-Paar
als Menge von Worten zu \emph{formalisieren},
was wir am Beispiel von \textbf{MAX} zeigen wollen:
\begin{enumerate}
    \item \emph{Abstraktion:}
        \\\textbf{Gegeben:} Eine Menge von Zahlen, z.B.: $\{1,2,3,4\}$
        \\\textbf{Gesucht:} Die größte Zahl der Menge, z.B. $4$.
    \item \emph{Kodierung:}
        \\\textbf{Gegeben:} Eine binäre Kodierung einer Menge von Zahlen, z.B.:
        \\$\{001, 010, 011, 100\}$
        \\\textbf{Gesucht:} Eine binäre Kodierung der größten Zahl aus der Menge, z.B.:
        \\$100$
\end{enumerate}

Formal können wir \textbf{MAX} also als eine ''Auswahl-Funktion'' aus einer Menge begreifen,
sodass gerade das Element ausgewählt wird, dass am größten ist.
Eine Funktion $f: D \rightarrow W$ lässt sich mengentheoretisch als Menge von Tupeln auffassen,
so dass gilt $f = \{[d,w]|d \in D \wedge w \in W\}$.
 
\noindent
Für unser Beispiel von oben gilt dann also
\begin{itemize}
    \item $[\{1,2,3,4\},4] \in \bf{MAX}$, bzw.:
    \item $[\{001, 010, 011, 100\}, 100] \in \bf{MAX}$
\end{itemize}

Der letzte Schritt ist nun, die \emph{gesamte} Funktion zu formalisieren, also eine Kodierung
für \textbf{MAX} anzugeben.
Dazu müssen wir eine binäre Kodierung von Tupeln von Binärdaten einführen.
Eine simple Variante wäre die folgende Kodierung:

\section{Weitere Werkzeuge der theoretischen Informatik}

\section{Drei grundlegende Fragen}
Zusammen mit dem Begriff eines Problems und seiner Formalisierung ist also der
\emph{Berechenbarkeitsbegriff} im Herzen dieses Skriptes.
Wir hätten auch andere Begriff auswählen können, um in die Ideen der theoretischen Informatik einzuführen:
Formale Sprachen, Automaten, Information, Aufwand, Überprüfbarkeit wären solche Kandidaten gewesen.
Das Problem und die Berechenbarkeit erlauben uns aber eine ganz Praxis-nahe Einführung.
Die anderen Begriffe werden wir in diesem Skript streifen, aber nicht in den Fokus setzen.

Mit unseren beiden Kernbegriffen können wir die drei Grundfragen dieses Skriptes stellen:
\begin{enumerate}
    \item Was lässt sich effizient berechnen?
    \item Was lässt sich überhaupt berechnen?
    \item Welche Rolle spielt die Formalisierung der Berechenbarkeit für die zwei ersten Fragen?
\end{enumerate}

Diese drei Fragen korrespondieren zu drei Grunddisziplinen der theoretischen Informatik:
\begin{enumerate}
    \item Komplexitätstheorie
    \item Berechenbarkeitstheorie
    \item Theorie der formalen Sprachen und der Automaten
\end{enumerate}

Im Rest des Skriptes werden wir die drei Fragen bearbeiten und
dabei die drei Grunddsiziplinen und ihre Fragestellungen, Ergebnisse und Methodiken kennenlernen.
