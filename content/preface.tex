\chapter{Vorwort}

Warum braucht es eine weitere (deutschsprachige) Einführung
in die theoretische Informatik?
Gute Einführungen zu dem Thema füllen bereits Bücherregale
(siehe Ende dieses Vorwortes).
Mit einem Schmunzeln könnte man sagen,
dass das Alleinstellungsmerkmal dieses Skriptes seine
\emph{Unvollständigkeit} ist.
Im Gegensatz zu anderen Einführungen wollen wir das Fach nicht in der Breite darstellen,
sondern uns einen Gedankengang, eine spezifische Überlegung,
ein \emph{Narrativ} herauspicken:
Wir wollen die Frage beantworten,
warum diejenigen
schneller, effizienter und präziser
in ihrer täglichen Arbeit als IT-Fachkräfte sind,
die das Kompendium der theoretischen Informatik beherrschen.
Die Kapitel 1 bis 6 umfassen genau diesen Erzählstrang:

In Kapitel 1 wird zunächst genauer analysiert,
was überhaupt ein Problem im Sinne der theoretischen Informatik ist
und wie wir es mit Hilfe von Abstraktion und Formalisierung mit den Werkzeugen
dieses Faches bearbeiten können.

In Kapitel 2 beschäftigen wir uns mit dem Aufwand,
den diese Probleme, beziehungsweise deren Berechnungen verursachen.
Wir differenzieren zwischen Problem, Algorithmus und Implementierung,
fassen Aufwand genauer als benötigten (Speicher-)Platz oder als benötigte Laufzeit.
Das Wachstum von Speicherplatz und Laufzeit lässt sich mit der
mit der Landau-Notation quantitativ fassen. 
Die Diskussion um Grenzen und Vorteile dieser Methode
gegenüber empirischen Messungen runden das Kapitel ab.

Viele Einführungen in die theoretische Informatik beginnen mit 
den Deterministisch Finiten Automaten (DFA) 
und der regulären Sprachen, die von ihnen erkannt werden.
In diesem Skript werden sie erst in Kapitel 3 diskutiert
und zwar als eine Art ``Hello World'' der Automatentheorie:
Wie beim Erlernen einer neuen Programmiersprache
ist es auch für die Automatentheorie zielführend
ein möglichst einfaches formales Konzept einzuführen,
um daran das generelle ``Handling'' zu zeigen. 
DFAs erlauben es die im vorigen Kapitel eingeführten
Konzepte von Speicherplatz und Laufzeit präzise zu fassen.
In einem Exkurs über reguläre Ausdrücke,
wird ein in der Praxis sehr relevantes Handwerkzeug einer IT-Fachkraft vermittelt.
Die Berechnungen, die mit einem DFA möglich sind, 
haben allerdings Grenzen, deren Diskussion das Kapitel abschließt.


Mit den Turing-Maschinen lernen wir in Kapitel 4 einen Formalismus kennen,
der diese Beschränkungen nicht teilt.
Turing-Maschinen sind der zentrale Formalismus sowohl
in der Komplexitätstheorie,
als auch in der Berechnungstheorie.
Auch sie erlauben (Speicher)platz und Laufzeit präzise zu quantifizieren,
darüberhinaus konnte bisher kein Formalismus gefunden werden,
der mächtiger als Turingmaschinen ist.

Die zentralen Ergebnisse und offenen Fragen der Komplexitätstheorie
werden in Kapitel 5 besprochen.
Diese Zusammenfassung ist ein Teil der Antwort auf die Frage,
warum IT-Fachkräfte mit einem starken Hintergrund in theoretischer Informatik
schneller, effizienter und präziser sind:
Zu wissen zu welcher Komplexitätsklasse ein Problem gehört,
macht die Wahl der Mittel, d.h. der nötigen algorithmischen Verfahren zielgerichtet

Die Theorie der (Un)berechenbarkeit ist das Thema in Kapitel 6.
Wo die Grenzen der automatisierten Informationsverarbeitung liegen,
ist das Wissen,
was Ortskundige in der IT-Landschaft von Zugereisten unterscheidet.
Einige überraschende Ergebnisse der Berechenbarkeitstheorie
bewahren professionelle IT-Kräfte davor,
Zeit und Energie in Fragestellungen zu stecken,
die sich aus prinzipiellen Gründen nicht beantworten lassen.

Kapitel 7 ist ein Exkurs: Kontextfreie Sprachen werden von Kellerautomaten erkannt,
und liegen damit genau zwischen den regulären Sprachen
und denen, die von Turingmaschinen erkannt werden.
Sie spielen im Compilerbau und dem Parsen von Programmiersprachen eine zentrale Rolle.

Kapitel 8 bietet einen Überblick,
wie Interessierte von den dem Inhalt dieses Skriptes tiefer in die theoretische Informatik
eintauchen können.

Die Kapitel bauen jeweils aufeinander auf,
weswegen diese Einführung linear zu lesen ist.
Die meisten Einführungen erlauben Auslassungen und Sprünge,
um nur eine Auswahl der Themen zu studieren.
Dieses Skript ist bereits eine solche Auswahl
und daher ist die Reihenfolge fix
und der Umfang minimal für das gewählte Narrativ.

Wenn wir zurück zur Daseinsberechtigung dieses Skriptes kommen,
stellen wir fest:
Viele zentrale Ergebnisse, Hintergründe und Konzepte
der theoretischen Informatik,
die für den gerade dargestellten Erzählstrang irrelvant sind,
finden sich nur in Fußnoten und Referenzen:
Wir werden nichts über Abzählbarkeit,
wenig über Abschlusseigenschaft formaler Sprachen,
linear-beschränkte Turingmaschinen,
oder Transduktoren zu sagen haben.
Wie bereits gesagt ist das Ziel des Skriptes aber nicht Vollständigkeit in der Breite,
sondern argumentative Kraft in der Tiefe:
Nach der Lektüre wird hoffentlich klar,
warum eine weitere Vertiefung des Faches lohnenswert ist,
auch in Bezug auf diese ausgesparten Konzepte.

Ein zweites Alleinstellungsmerkmal findet sich im Fokus auf grundlegende
wissenschaftsphilosophische und metatheoretische Fragstellungen,
die ansonsten in anderen Einführungen eher am Rande gestreift
oder einfach ignoriert werden.
Was genau meinen wir mit Begriffen wie ``Problem'', ``Berechnung'', ``Effizienz''?
Welche Rolle spielen Konventionen in der theoretischen Informatik?
Welche Alternativen gibt es zum Methodenkoffer der theoretischen Informatik
bei praktischen Fragestellungen
und warum haben letztere trotzdem mehr als eine Daseinsberechtigung?
Diese Fragen können leicht abgetan werden, frei nach dem Fregeschen Dictum
``philosophia sunt, non leguntur!''\footnote{
    In etwa: ``Das ist Philosophie,
    das lesen wir (als Informatiker:innen) nicht!''
    Frege beklagt in \cite{frege_grundgesetze} (7),
    dass der Mehrwert seiner Beiträge weder in der akademischen Philosophie,
    noch in der akademischen Mathematik Anerkennung finden.
}
Das Buch verfolgt aber den Ansatz,
dass sich Studierende der theoretischen Informatik
\emph {leichter} mit dem klassischen Handwerkszeug tun,
wenn sie Antworten auf diese philosophischen Fragestellungen mitdiskutieren.
Die kritische Perspektive der (formal-analytischen) Philosophie
verspricht mehr Präzision und Klarheit
und weniger Fragezeichen in den Gesichtern der Studierenden.

Ein dritter Aspekt, der dieses Skript von anderen Einführungen unterscheidet,
ist der Fokus auf die Komplexitätstheorie,
also die Theorie von Problemklassen,
die sich wesentlich aufgrund ihrer ``Schwierigkeit'' unterscheiden.
Dieser Aspekt und der Zusammhang zwischen theoretischer Informatik und ``Algorithmik''\footnote{
    Wir verstehen darunter das Handwerkzeug, für gegebene Probleme,
    die effizientesten Algorithmen und Datenstrukturen zu identifizieren 
    und zu implementieren}
ist in den meisten Einführungen zur theoretischen Informatik
erst spät im Text oder überhaupt nicht zu finden.
In vielen Vorlesungen wird die Komplexitätstheorie nicht ausreichend diskutiert, 
da im fortgeschrittenen Semester Abstriche gemacht werden müssen.
In diese Situation zu kommen, wird von diesem Skript aufgrund des Aufbaus deutlich erschwert.

Für wen ist dieses Skript nun geschrieben?
Das ursprüngliche Skript wurde begleitend zur Veranstaltung
\emph{Theoretische Informatik (Wirtschaftsinformatik)}
an der DHBW Heilbronn erstellt.
Es richtet sich vor allem an Fachhochschul- und BA-Student:innen,
die Informatik eher als Teil- oder Nebenfach belegen.
Desweiteren wird das Buch aus oben genannten Gründen auch für Studierende der Philosophie
in der analytisch-angelsächischen Tradition (d.h. mit einem Fokus auf formales Arbeiten)
eine gewinnbringende Einführung in das Fach bieten.
Für Studierende der Informatik auf Universitätsniveau kann das Skript 
\emph{ergänzend} hilfreich sein,
sollte allerdings mit einem vollständigen Kompendium ergänzt werden,
um Prüfungen erfolgreich zu bestehen.
Die folgende Aufstellung von Einführungen in die theoretische Informatik
listet geeignete Kandidaten für eine Komplementierung auf
und spiegelt dabei den Geschmack des Autors wieder
und hat daher keinen Anspruch auf Vollständigkeit:
\begin{itemize}
    \item  \cite{hoffmann} bietet ein sehr umfassendes Kompendium.
    \item  Einen kurzen und konzisen Überblick bietet \cite{schoening},
            die Reihenfolge der Kapitel entspricht dem kanonischen Aufbau
            einer universitären Vorlesung.
    \item  Für eine Compiler-zentrierte Einführung ist \cite{hedtstueck}
           zu empfehlen.
    \item  Wer Wert auf vollständige formale Beweise legt,
        wird bei \cite{erkpriese} fündig.
    \item  \cite{neubert} hat die niedrigeste Einstiegshürde (es wird viel und ausführlich erklärt) und hat einen starken Fokus auf Algorithmen bzw. Algorithmik.
    \item  Der (englisch-sprachige) Klassiker ist \cite{hopcroftullman},
        für puristische und historisch interessierte Leser:innen zu empfehlen.
    \item  \cite{barak} ist ein Skript in der Entstehung, es ist englisch und offen im Netz zugänglich.
\end{itemize}

Um das Skript lesen und verstehen zu können,
sind Vorkenntnisse notwendig,
die wir in \autoref{sec:grundlagen} kurz streifen.
Der Abschnitt ist als Wiederholung und Kontrolle gedacht,
nicht als allumfassende Einführung in die genannten Konzepte.
Werden beim Durchlesen Lücken bemerkt,
beinhalet das Kapitel ausreichend Literaturempfehlungen,
um diese zu schließen.

