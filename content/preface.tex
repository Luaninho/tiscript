\chapter{Vorwort}

Warum braucht es eine weitere (deutschsprachige) Einführung
in die theoretische Informatik?
Gute Einführungen zu dem Thema füllen bereits Bücherregale
(siehe Ende dieses Vorwortes).
Mit einem Schmunzeln könnte man sagen,
dass das Alleinstellungsmerkmal dieses Skriptes seine
\emph{Unvollständigkeit} ist.
Im Gegensatz zu anderen Einführungen wollen wir das Fach nicht in der Breite darstellen,
sondern uns einen Gedankengang, eine spezifische Überlegung,
ein \emph{Narrativ} herauspicken:
Wir wollen die Frage beantworten,
warum diejenigen IT-Fachkräfte Probleme
schneller, effizienter und präziser lösen,
die das Kompendium der theoretischen Informatik beherrschen.
Die Kapitel 1 bis 6 umfassen genau diese Überlegung:

In \emph{Kapitel 1} wird zunächst genauer analysiert,
was überhaupt ein Problem im Sinne der theoretischen Informatik ist
und wie wir durch Abstraktion und Formalisierung von IT-Alltagsaufgaben
zu den Problemen kommen, die wir mit den Werkzeugen dieses Faches bearbeiten können.
Wir zeigen beispielhaft,
wie ein Problem als formale Sprache repräsentiert werden kann.

In \emph{Kapitel 2} beschäftigen wir uns mit dem Gegenbegriff zum Problem:
Dessen Lösung, auch \emph{Algorithmus} genannt.
Wir differenzieren zwischen Algorithmus und Implementierung
und lernen einen Formalismus zur Implementierung von Algorithmen kennen:
Deterministisch Finite Automaten (DFA).
DFAs ``erkennen'' eine spezielle Klasse von formalen Sprachen,
\emph{regulären Sprachen},
das heißt alle Probleme, die mit regulären Sprachen repräsentiert werden können,
können von DFAs berechnet werden.
In einem Exkurs über \emph{reguläre Ausdrücke},
wird ein in der Praxis sehr relevantes Handwerkzeug einer IT-Fachkraft vermittelt.

Zu Beginn von \emph{Kapitel 3} identifizieren wir Probleme,
die mit einem DFA nicht zu lösen sind
und mit dem Pumping-Lemma die Methode, wie wir diese Beschränkung beweisen können.
Mit den \emph{Turing-Maschinen} lernen wir einen Formalismus kennen,
der diese Beschränkungen nicht teilt.
Turing-Maschinen sind der zentrale Formalismus sowohl
in der Komplexitätstheorie,
als auch in der Berechnungstheorie.
Es konnte bisher kein Formalismus gefunden werden,
der ``mächtiger'' als Turingmaschinen ist.
Mit den Turing-Maschinen haben wir das nötige Konzept an der Hand,
um die Hauptfrage des Skriptes zu beantworten.

In \emph{Kapitel 4} zeigen wir, 
wie wir den \emph{Aufwand} quantifizieren können,
den Berechnungen verursachen. 
Wir fassen Aufwand genauer als Laufzeit einer Turingmaschine (zeitlicher Aufwand) 
oder dessen benötigten (Speicher-)Platz (räumlicher Aufwand).
Das Wachstum von Laufzeit und Speicherplatz lässt sich
mit der Landau-Notation quantitativ fassen.
Da man andere Implementierungsformalismen für Algorithmen auf Turingmaschinen simulieren kann,
können wir die Aufwandsquantifkation von Turinmaschinen auf jene Formalismen übersetzen.
Die Diskussion um Grenzen und Vorteile theoretischer Methoden 
gegenüber empirischen Messungen runden das Kapitel ab.

Zentrale Ergebnisse und einige offene Fragen der Komplexitätstheorie
werden in \emph{Kapitel 5} besprochen.
Diese Zusammenfassung ist ein Teil der Antwort auf die Frage,
warum IT-Fachkräfte mit einem starken Hintergrund in theoretischer Informatik
schneller, effizienter und präziser sind:
Zu wissen zu welcher Komplexitätsklasse ein Problem gehört,
macht die Wahl der Mittel,
also der nötigen algorithmischen Verfahren zielgerichtet.

Die Theorie der (Un)berechenbarkeit wird in \emph{Kapitel 6} thematisiert.
Wo die Grenzen der automatisierten Informationsverarbeitung liegen,
ist das Wissen,
was Ortskundige in der IT-Landschaft von Zugereisten unterscheidet.
Einige überraschende Ergebnisse der Berechenbarkeitstheorie
bewahren professionelle IT-Kräfte davor,
Zeit und Energie in Fragestellungen zu stecken,
die sich aus prinzipiellen Gründen nicht beantworten lassen.

\emph{Kapitel 7} ist ein Exkurs: Kontextfreie Sprachen werden von Kellerautomaten erkannt,
und liegen damit genau zwischen den regulären Sprachen
und denen, die von Turingmaschinen erkannt werden.
Sie spielen beim Parsen von Programmiersprachen eine zentrale Rolle.
Diese Aspekte rechtfertigen eine gesonderte Behandlung,
auch wenn sie außerhalb des Leitgedankens dieses Skriptes sind.

\emph{Kapitel 8} bietet einen Überblick,
wie Interessierte vom Inhalt dieses Skriptes tiefer in die theoretische Informatik
eintauchen können.
Es listet einige ``Absprungspunkte'' auf und zeigt,
wo diese in gängigen Einführungen und weiterführender Literatur diskutiert werden:
Hierzu gehören die Chomsky-Hierarchie der formalen Sprachen,
Grammatiken als Sprach-Kreatoren (im Gegensatz zu Automaten als Sprach-Akzeptoren),
weitere Komplexitätsklassen und
der Zusammenhang zwischen der Automatentheorie und der formalen Logik.

Die Kapitel 1-6 bauen jeweils aufeinander auf,
weswegen diese linear zu lesen sind.
Die meisten Einführungen erlauben Auslassungen und Sprünge,
um nur eine Auswahl der Themen zu studieren.
Dieses Skript ist bereits eine solche Auswahl
und daher ist die Reihenfolge fix
und der Umfang annähernd minimal für das gewählte Narrativ.
Auch Kapitel 7 und 8 bauen auf Vorhergeschriebenes auf,
sie sind allerdings optional
und für das Verständnis des Hauptnarrativs nicht notwendig.

Viele zentrale Ergebnisse, Hintergründe und Konzepte
der theoretischen Informatik,
die für den gerade dargestellten Erzählstrang irrelvant sind,
finden sich in diesem Skript nur in Fußnoten und Referenzen:
Wir werden nichts über Abzählbarkeit,
wenig über Abschlusseigenschaften formaler Sprachen,
linear-beschränkte Turingmaschinen,
oder Transduktoren zu sagen haben.
Ein Alleinstellungsmerkmal dieses Skriptes ist nicht Vollständigkeit in der Breite,
sondern argumentative Kraft in der Tiefe:
Nach der Lektüre wird hoffentlich klar,
warum eine weitere Vertiefung des Faches lohnenswert ist,
auch in Bezug auf diese ausgesparten Konzepte.

Ein zweites Alleinstellungsmerkmal findet sich im Fokus auf grundlegende
wissenschaftsphilosophische und metatheoretische Fragstellungen,
die ansonsten in anderen Einführungen eher am Rande gestreift
oder ignoriert werden.
Was genau meinen wir mit Begriffen wie ``Problem'', ``Berechnung'', ``Effizienz''?
Welche Rolle spielen Konventionen in der theoretischen Informatik?
Welche Alternativen gibt es zum Methodenkoffer der theoretischen Informatik
bei praktischen Fragestellungen
und warum haben letztere trotzdem eine Daseinsberechtigung?
Diese Fragen können leicht abgetan werden, frei nach dem Fregeschen Dictum
``philosophia sunt, non leguntur!''\footnote{
    In etwa: ``Das ist Philosophie,
    das lesen wir (als Informatiker:innen) nicht!''
    Frege beklagt in \cite{frege_grundgesetze} (7),
    dass der Mehrwert seiner Beiträge weder in der akademischen Philosophie,
    noch in der akademischen Mathematik Anerkennung finden.
}
Das Buch verfolgt aber den Ansatz,
dass sich Studierende der theoretischen Informatik
\emph {leichter} mit dem klassischen Handwerkszeug tun,
wenn sie Antworten auf diese Fragestellungen mitdiskutieren.

Ein dritter Aspekt, der dieses Skript von einigen anderen Einführungen unterscheidet,
ist die prominentere Rolle der Komplexitätstheorie,
also der Theorie von Problemklassen,
die sich aufgrund ihrer Schwierigkeit unterscheiden.
Dieser Aspekt und der Zusammhang zwischen theoretischer Informatik und ``Algorithmik''\footnote{
    Wir verstehen darunter die Fähigkeit,
    für gegebene Probleme die nach Forschungsstand
    effizientesten Algorithmen und Datenstrukturen zu identifizieren
    und zu implementieren.}
ist in den meisten Einführungen zur theoretischen Informatik
erst spät im Text oder überhaupt nicht zu finden.
In vielen Vorlesungen wird die Komplexitätstheorie nicht ausreichend diskutiert,
da im fortgeschrittenen Semester Abstriche gemacht werden müssen.
In diese Situation zu kommen, wird von diesem Skript aufgrund des Aufbaus
(vor allem Kapitel 2 und 5) deutlich erschwert.

Für wen ist dieses Skript nun geschrieben?
Das ursprüngliche Skript wurde begleitend zur Veranstaltung
\emph{Theoretische Informatik (Wirtschaftsinformatik)}
an der DHBW Heilbronn erstellt.
Es richtet sich vor allem an Fachhochschul- und duale Student:innen,
die Informatik eher als Teil- oder Nebenfach belegen.
Desweiteren wird das Skript aus oben genannten Gründen auch für Studierende der Philosophie
in der analytisch-angelsächischen Tradition (d.h. mit einem Fokus auf formales Arbeiten)
eine gewinnbringende Einführung in das Fach bieten.
Für Studierende der Informatik auf Universitätsniveau kann das Skript
hilfreich sein,
sollte allerdings mit einem vollständigen Kompendium ergänzt werden,
um den klassischen Prüfungsstoff erfolgreich zu beherrschen.
Die folgende Aufstellung von Einführungen in die theoretische Informatik
listet geeignete Kandidaten für diese Ergänzung auf
und spiegelt dabei lediglich den Geschmack beziehungsweise den Kenntnisstand des Autors wieder
und hat keinen Anspruch auf Vollständigkeit:
\begin{itemize}
    \item  Einen kurzen und konzisen Überblick bietet \cite{schoening}.
    \item  Für eine Compiler-zentrierte Einführung ist \cite{hedtstueck}
           zu empfehlen.
    \item  Wer Wert auf vollständige formale Beweise legt,
           wird bei \cite{erkpriese} fündig.
    \item  \cite{neubert} hat die niedrigeste Einstiegshürde (es wird viel und ausführlich erklärt)
           und hat einen starken Fokus auf Algorithmen bzw. Algorithmik.
    \item  Der (englisch-sprachige) Klassiker ist \cite{hopcroftullman},
           für puristische und historisch interessierte Leser:innen zu empfehlen.
    \item  \cite{barak} ist ein Skript in der Entstehung,
           es ist in englisch verfasst und offen im Netz zugänglich.
    \item  \cite{hoffmann} bietet ein sehr umfassendes Kompendium
            und ist für alle geeignet, die sich von den weiteren Alternativen nicht angesprochen fühlen.
\end{itemize}

Um das Skript lesen und verstehen zu können,
sind Vorkenntnisse notwendig,
die wir in \autoref{sec:grundlagen} kurz streifen.
Der Abschnitt ist als Wiederholung und Kontrolle gedacht,
nicht als allumfassende Einführung in die genannten Konzepte.
Werden beim Durchlesen Lücken bemerkt,
beinhaltet das Kapitel Literaturempfehlungen,
um diese zu schließen.

