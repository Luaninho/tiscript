\chapter{Reguläre Sprachen}

\section{Algorithmus und Implementierung}

In \autoref{einleitung} haben wir festgehalten:
Probleme lassen sich als als formale Sprachen repräsentieren.
Wie machen wir diese Formalisierung operabel,
also wie können wir \emph{Lösungen} für Probleme angeben?
In der Informatik nutzen wir für Problemlösungen \emph{Algorithmen}.
Wir suchen also nach einer geeigneten Repräsentation eines Algorithmus,
so dass wir auf den Überlegungen zu formalen Sprachen im letzten Kapitel aufbauen können.

Was genau ist aber ein Algorithmus?
Frei nach Donald E. Knuth (\cite{knuth1}, 4-6)
ist ein Algorithmus eine schrittweise Anweisung zur Lösung eines Problems,
welche die folgenden fünf Eigenschaften erfüllt:\footnote{
    In \cite{knuth1} (ebd.) finden wir auch eine Liste ähnlicher Begriffe:
    Rezept, Prozess, Methode, Technik, Prozedur oder Routine.
    Ein Algorithmus ist von diesen zu unterscheiden,
    auch wenn Vergleiche als hilfreiche Verständnisanalogien dienen können.
}
\begin{enumerate}
    \item Seine Durchführung endet (``finiteness'').
    \item Er ist unmissverständlich formuliert (``definiteness'').
    \item Er hat einen (möglicherweise leeren) Input.
    \item Er liefert einen (möglicherweise komplexen) Output, abhängig vom Input.
    \item Er lässt sich durchführen (``effectiveness'').
\end{enumerate}

Das Kriterium 1 unterscheidet einen Algorithmus von einer \emph{Berechnungsmethode},
von der wir nicht wissen,
ob sie für jeden gegebenen Input in endlichen Schritten einen Output liefert.
Wir werden diesen Unterschied in \autoref{derBarbierUndDerLuegner} wieder aufgreifen.

Am besten machen wir die Bedeutung der Kriterien anhand eines Beispiels klar.
Wir wollen einen Algorithmus angeben, der unser \textbf{EVEN}-Problem löst.
Zur Erinnerung: \textbf{EVEN} ist die Menge aller geraden Zahlen
in der in \autoref{einleitung} eingeführten Kodierung.
Ein Algorithmus löst dieses Problem,
indem er angibt,
ob für ein gegebenes Wort $w \in \{0,1\}^*$ gilt: $w \in EVEN$.
Wir nutzen für unsere erste Idee die Tatsache,
dass alle geraden Zahlen in der gewählten Kodierung auf das Zeichen 0 enden.
Da wir noch keine Alternative eingeführt haben,
geben wir diesen ``naiven'' Algorithmus informell an:

\begin{enumerate}
    \item Setze den Ausgabewert auf 0 (oder falsch).
    \item Wenn kein Zeichen mehr übrig ist, gib den Ausgabewert aus.
    \item Lese das nächste Zeichen $a$.
    \item Wenn $a = 1$, setze den Ausgabewert auf 0 (oder falsch).
    \item Wenn $a = 0$, setze den Ausgabewert auf 1 (oder wahr).
    \item Gehe zu Schritt 2.
\end{enumerate}

Der Algorithmus ist endlich (Kriterium 1),
denn er endet,
sobald das letzte Zeichen des Wortes gelesen wurde.
Er ist so unmissverständlich formuliert,
wie das in der deutschen Sprache möglich ist (Kriterium 2).
Er hat auch einen Input (die Zahl als binärkodiertes Wort, Kriterium 3)
und einen Output (0 oder 1, beziehungsweise falsch oder wahr),
der angibt, ob die Zahl (nicht) gerade ist (Kriterium 4).
Jeder seiner Einzelschritte ist einfach und durchführbar,
wir verlangen also keine unmöglichen Dinge (Kriterium 5).

Der Algorithmus ist zwar einfach, aber wir haben ihn mit Grund naiv genannt,
denn er erkennt nicht nur \textbf{EVEN}, sondern $EVEN \cup 0^*$.
Für unseren Zweck,
also zu zeigen wie wir Algorithmen in der theoretischen Informatik fassen können,
ist dieser Fehler zunächst verkraftbar und wir wollen uns nicht damit aufhalten.
Wie der Algorithmus korrigiert werden kann,
ist Gegenstand von Aufgabe 2.

Wenn wir für ein Problem einen Algorithmus angeben können,
dann ist das Problem \emph{berechenbar}.
Offensichtlich gibt es zu einem Problem mehr als einen Algorithmus,
der es löst, daher schließen sich auch interessante Fragen an:\footnote{Für diejenigen, die dies nicht so einfach akzeptieren wollen:
Sei ein Algorithmus A für ein Problem gegeben, dann ist der Algorithmus A', der wie A ist,
nur zusätzlich $1+1$ errechnet und das Ergebnis ignoriert,
auch eine Lösung für das Problem, aber von A unterschiedlich.}
\begin{itemize}
    \item Wie können wir den Aufwand für diese Algorithmen sinnvoll angeben?
    \item Gibt es einen Algorithmus, der das Problem ``am besten'' löst?
    \item Wie können wir beweisen, dass es keinen ``besseren'' Algorithmus gibt?
\end{itemize}
Diese Fragen werden wir in den folgenden Kapiteln beantworten.
Nun müssen wir uns zunächst die Frage stellen,
in welcher Form wir Algorithmen angeben können,
damit diese Fragen überhaupt sinnvoll und formal korrekt beantwortet werden können.

In der IT-Praxis werden Algorithmen in Programmen ausformuliert,
geschrieben in einer Programmiersprache.
Diese Programme nennt man \emph{Implementierungen} des Algorithmus.
Eine Implementierung ist also eine konkrete Realisierung des Algorithmus.
Für einen Algorithmus kann es mehrere Implementierungen geben,
selbst in einer Programmiersprache.
Wir suchen eine Möglichkeit Algorithmen zu implementieren,
die es uns erlaubt die obigen Fragen möglichst einfach zu beantworten.
Warum benutzen wir hierfür nicht einfach schon bekannte Programmiersprachen?
Fassen wir eine Programmiersprache als
Menge aller syntaktisch wohlgeformten Programme in dieser Sprache auf, 
haben wir als Gegenstand eine formale Sprache.
In diesem Fall wäre es also nicht notwendig,
ein neues Konzept einzuführen.

Allerdings sind Programmiersprachen für praktische Zwecke angelegt,
unser Fokus ist ein Theoretischer:
Wir wollen mit Beweisen und Definitionen arbeiten
und hier ist es sinnvoller mit einem Formalismus zu arbeiten,
der ``einfacher'' ist als eine typische Programmiersprache.
Um Programierer:innen bei ihrer Arbeit möglichst effizient zu unterstützen,
ist eine Programmiersprache typischerweise sehr ausdrucksstark.
Der von von uns gesuchte Formalismus hat aber idealerweise nur wenige, einfache Bestandteile.
Damit gelingt es uns zum Beispiel schneller Kriterium 5 zu behandeln:
Wir müssen nur für wenige ``Bauteile'' einer Implementierung zeigen,
dass sie alle einfach und prinzipiell nutzbar sind.\footnote{
    Natürlich hat unser Formalismus letztlich eine Verbindung zu Programmiersprachen,
    diese wollen wir in \autoref{keller} und \autoref{ch:theorie} diskutieren.
}

Eine Möglichkeit,
die Implementierungen von Algorithmen in der theoretischen Informatik
anzugeben, sind \emph{Automaten}.
Ein Automat kann als eine abstrakte Maschine verstanden werden,
die einen Input bekommt, 
dabei mit simplen Einzelschritten läuft
und einen definiten Output liefert.
% TODO Bild.
Der Zusammenhang zwischen einer formalen Sprache und dem Automat kann so formuliert werden:
Ein Automat bekommt ein Wort als Input und entscheidet über ein Outputsignal,
ob es zu der formalen Sprache gehört oder nicht.
Wenn eine formale Sprache ein Problem repräsentiert,
gibt der Automat also ein Verfahren an, 
wie das Problem gelöst werden kann.
Man kann auch sagen:
Der Automat ist eine Implementierung eines Algorithmus,
der das Problem löst.

\section{Deterministisch Finite Automaten}

Kommen wir noch einmal auf den (naiven) Beispielsalgorithmus
aus dem vorangegangen Abschnitt zurück
und überlegen uns, welche Komponenten der Automat haben muss,
um den genannten Algorithmus zu implementieren:
\begin{itemize}
    \item Teil es Automaten muss in jedem Fall eine Menge von Zeichen sein,
        aus denen die Inputwörter zusammengesetzt sind.
        Wir nennen diese Menge \emph{Eingabealphabet}
        und bezeichnen dieses wie bei den formalen Sprachen mit $\Sigma$,
        für unser Beispiel gilt $\Sigma = \{0,1\}$.

    \item Ein Automat hat eine Menge von \emph{Zuständen}, in denen er sich befindet.
        Der Automat, den wir suchen, scheint zwei Zustände zu haben:
        \begin{enumerate}
            \item Das letzte gelesene Zeichen war eine 1
                (oder wir haben noch kein Zeichen gelesen).
            \item Das letzte gelesene Zeichen war eine 0.
        \end{enumerate}
        Die Menge der Zustände eines Automaten bezeichnen wir mit $Z$.
        In unserem Fall ist $Z = \{z_1, z_0\}$.

    \item Während wir das Eingabewort lesen,
        kann sich der Zustand des Automaten ändern.
        Dies geben wir mit der \emph{Übergangsfunktion} $\delta$ an:
        $\delta: \Sigma \times Z \rightarrow Z$.
        In unserem Fall können wir $\delta$ so angeben:
        \begin{itemize}
            \item Lesen wir eine 0 und sind in Zustand $z_1$,
                dann gehen wir in Zustand $z_0$:\linebreak
                $[0,z_1,z_0]$
            \item Lesen wir eine 1 und sind in Zustand $z_1$,
                dann bleiben wir in Zustand $z_1$:\linebreak
                $[1,z_1,z_1]$
            \item Lesen wir eine 0 und sind in Zustand $z_0$,
                dann bleiben wir in Zustand $z_0$:\linebreak
                $[0,z_0,z_0]$
            \item Lesen wir eine 1 und sind in Zustand $z_0$,
                dann gehen wir in Zustand $z_1$:\linebreak
                $[1,z_0,z_1]$
        \end{itemize}
        Also ist $\delta = \{[0,z_1,z_0] [1,z_1,z_1] [0,z_0,z_0] [1,z_0,z_1]\}$

    \item Wir müssen noch angeben, in welchem Zustand der Automat ``startet'',
        der \emph{Anfangszustand} (allgemein bezeichnet mit $z_i$)
        ist in unserem Beispiel $z_1$.

    \item Als letztes müssen wir den Ausgabewert definieren,
        also ob der Automat das Wort akzeptiert oder nicht.
        Dies wird durch den Zustand definiert, indem sich der Automat
        befindet, wenn das letzte Zeichen gelesen wurde.
        Generell kann es mehr als einen akzeptierenden Zustand geben,
        daher geben wir die \emph{Endzustände} $E$ als Menge an,
        in unserem Beispiel: $E = \{z_0\}$.
\end{itemize}

Ganz allgemein können wir einen Automaten A in der Sprache der Mengenlehre
als 5-Tupel (oder Quintupel angeben): $A = [\Sigma, Z, \delta, z_i, E]$:
\begin{itemize}
    \item $\Sigma$ ist das Eingabealphabet.
    \item Z ist die Menge der Zustände.
    \item $\delta: \Sigma \times Z \rightarrow Z$ ist die Übergangsfunktion.
    \item $z_i$ ist der Startzustand.
    \item $E$ ist die Menge der Endzustände.
\end{itemize}
Einen solchen Automat nennen wir Deterministisch Finiten Automat (DFA).
Bevor wir die beiden Begriffe deterministisch und finit diskutieren,
wollen wir noch die graphische Spezifikation für Automaten kennenlernen. 
Der Automat,
der unserem Algorithmus entspricht lässt sich so wie in \autoref{fig:dfaeven} angeben.

\begin{figure}[ht] % ’ht’ tells LaTeX to place the figure ’here’ or at the top of the page
\centering % centers the figure
\begin{tikzpicture}
	\node[state, initial] (z1) {$z_1$};
	\node[state, accepting, right of=z1] (z0) {$z_0$};
	\draw (z1) edge[bend left, above] node{0} (z0)
	(z1) edge[loop above] node{1} (z1)
	(z0) edge[bend left, below] node{1} (z1)
	(z0) edge[loop above] node{0} (z0);
\end{tikzpicture}
\caption{Automat, der den naiven Algorithmus für EVEN implementiert.}
\label{fig:dfaeven}
\end{figure}

Dabei entsprechen die Kreise den Zuständen,
die Pfeile definieren die Überangsfunktion,
ein freistehender Pfeil auf einen einzelnen Zustand bestimmt den Startzustand
und alle Kreise mit doppeltem Radius sind Endzustände.
Das Eingabealphabet lässt sich aus den Pfeilbeschriftungen ableiten.

Um zu verstehen, was determinstisch und finit genau bedeutet,
müssen wir ein paar Hilfskonzepte einführen:
\begin{itemize}
    \item Ein \emph{Schnappschuss} s eines DFA A ist ein geordnetes Paar $s = [z, w]$
        mit $z \in Z$ und $w \in \Sigma^*$.
        Ein Schnappschuss beschreibt,
        in welchem Zustand A ist und welches Wort A noch zu lesen hat.
        Nehmen wir den DFA von oben, dann wäre $[0010,z_1]$ ein Beispiel:
        Wir müssen noch $0010$ lesen und sind dabei in Zustand $z_1$.
    \item Eine \emph{Schnappschussfolge} S auf einem DFA A
        ist ein n-Tupel von Schnapp-schüssen. 
        Für jedes Paar aufeinanderfolgender Schnappschüsse $s_n$ und $s_{n+1}$ gilt,
        dass sie einen Übergang des Automaten A auf dem verbliebenen Restwort repräsentieren:
        \begin{itemize}
            \item $z_{n+1} = \delta(tw(w_{n},0,1), z_n)$
            \item $w_{n+1} = tw(w,1,|w|-1)$.
        \end{itemize}
        Zum Beispiel ist dies eine Schnappschussfolge für das obige Beispiel:\linebreak
        $[[0010,z_1],[010, z_0],[10, z_0],[0,z_1],[\epsilon,z_0]]$.
    \item Eine Schnappschussfolge $S = [s_0, \ldots s_{w-1}]$ auf A
        heißt \emph{Lauf} für $w$ auf A, wenn gilt:
        \begin{itemize}
            \item Wir haben $w$ als Input und starten beim Anfangszustand:
                $s_0 = [w,z_i]$ 
            \item Wir enden, wenn das Wort ``aufgebraucht'' ist:
                $s_{w-1} = [\epsilon, z]$ mit $z \in Z$,

        \end{itemize}
    \item Ein Lauf für w auf A heißt \emph{akzeptierend}, wenn gilt:
        $z_{w-1} \in E$,
        wenn der letzte Zustand des letzten Schnappschusses in der Schnappschussfolge
        ein Endzustand ist.
        Wir schreiben kurz: $w \rightarrow A,E$
        für ``der Lauf von w auf A ist akzeptierend''. 


\end{itemize}

Ein DFA A ist \emph{deterministisch}, weil es genau einen Lauf
für ein beliebiges Wort w gibt (der Lauf ist eindeutig determiniert).
Ein DFA A ist \emph{finit}, also endlich, weil der Lauf für jedes w auf A endlich ist.

Ein DFA A bestimmt also immer eine Sprache L aller der Wörter,
deren Lauf auf A akzeptierend ist.
Wir schreiben auch kurz: $L(A) = \{w|w \rightarrow A,E\}$.


Viele formale Sprachen haben unendlich viele Wörter,
so auch $L_{MATCH}$.
Daraus folgt: wir können sie nicht einfach extensiv angeben (''aufzählen''),
sondern müssen Mittel und Wege finden, sie formal zu charakterisieren.
Zwei Methoden bieten sich an:
\begin{enumerate}
    \item Sprach-\emph{Generatoren}, d.h. Formalismen,
        mit denen alle Wörter einer Sprache abgeleitet werden können
        (und nicht mehr).
    \item Sprach-\emph{Akzeptoren}, d.h. Formalismen,
        die für eine gegebenes Wort entscheiden,
        ob es zur Sprache gehört (oder nicht).\footnote{
            Wie wir in \autoref{derBarbierUndDerLuegner} sehen werden,
            ist dieses ''oder nicht'' leider nicht so trivial.}
\end{enumerate}

Sprach-Generatoren sind nicht der Fokus dieses Skriptes, obwohl wir mit den Grammatiken
in \autoref{grammatiken} einen solchen Formalismus kennen lernen werden.\footnote{
Einige Lehrbücher der theoretischen Informatik bauen Ihren Stoff didaktisch anhand der Grammatiken
auf (sie erlauben die Sprachen hierarchisch zu klassifizieren).
Wer dieses Skript begleitend z.B. zu \cite{schoening} liest,
sollte diesen Unterschied präsent haben.}
Unser Fokus wird auf den Sprach-Akzeptoren liegen,
da sie sich gut für einen Problem-orientierten Ansatz eignen.

%TODO Automatentheorie: Akzeptor vs Transduktor

\section{Minimalisierung}
\section{Reguläre Ausdrücke}
