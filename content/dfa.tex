\chapter{Reguläre Sprachen}

\section{Algorithmus und Implementierung}

In \autoref{einleitung} haben wir festgehalten:
Probleme lassen sich als als formale Sprachen repräsentieren.
Wie machen wir diese Formalisierung operabel,
also wie können wir \emph{Lösungen} für Probleme angeben?
In der Informatik nennen wir Problemlösungen \emph{Algorithmen}.
Wir suchen also nach einer geeigneten Repräsentation eines Algorithmus,
so dass wir auf den Überlegungen zu formalen Sprachen im letzten Kapitel aufbauen können.

Was genau ist aber ein Algorithmus?
Frei nach Donald E. Knuth (\cite{knuth1}, 4-6)
ist ein Algorithmus eine schrittweise Anweisung zur Lösung eines Problems,
welche die folgenden fünf Eigenschaften erfüllt:\footnote{
    In \cite{knuth1} (ebd.) finden wir auch eine Liste ähnlicher Begriffe:
    Rezept, Prozess, Methode, Technik, Prozedur oder Routine.
    Aber ein Algorithmus ist von diesen zu unterscheiden,
    auch wenn der Vergleich eine hilfreiche Verständnisanalogie sein kann.
}
\begin{enumerate}
    \item Seine Durchführung endet (``finiteness'').
    \item Er ist unmissverständlich formuliert (``definiteness'').
    \item Er hat einen (möglicherweise leeren) Input.
    \item Er liefert einen (möglicherweise komplexen) Output, abhängig vom Input.
    \item Er lässt sich durchführen (``effectiveness'').
\end{enumerate}

Das Kriterium 1 unterscheidet einen Algorithmus von einer Berechnungsmethode,
von der wir nicht wissen, ob sie für jeden gegebenen Input in endlichen Schritten einen
Output liefert.
Wir werden diesen Unterschied in \autoref{derBarbierUndDerLuegner} wieder aufgreifen.

Am besten machen wir die Bedeutung der Kriterien anhand eines Beispiels klar.
Wir wollen einen Algorithmus angeben, der unser \textbf{EVEN}-Problem löst.
Zur Erinnerung: \textbf{EVEN} ist die Menge aller geraden Zahlen
in der in \autoref{einleitung} eingeführten Kodierung.
Ein Algorithmus löst dieses Problem,
indem er angibt,
ob für ein gegebenes Wort $w \in \{0,1\}^*$ gilt: $w \in EVEN$.
Wir nutzen für unseren Algorithmus die Tatsache,
dass alle geraden Zahlen in der gewählten Kodierung auf das Zeichen 0 enden.
Da wir noch keine Alternative eingeführt haben,
geben wir den Algorithmus informell an:

\begin{enumerate}
    \item Setze den Ausgabewert auf 0 (oder falsch).
    \item Lese das nächste Zeichen $a$, beginnend am linken Rand des Input-Wortes.
    \item Wenn $a = 1$, setze den Ausgabewert auf 0 (oder falsch) vor.
    \item Wenn $a = 0$, setze den Ausgabewert auf 1 (oder wahr) vor.
    \item Wenn $a$ nicht das letzte Zeichen ist, gehe zu Schritt 1.
    \item Wenn $a$ das letzte Zeichen war, gib die vorbereitete Ausgabe aus.
\end{enumerate}

Der Algorithmus ist endlich (Kriterium 1),
denn er endet,
sobald das letzte Zeichen des Wortes gelesen wurde und alle Worte endlich sind.
Er ist so unmissverständlich formuliert,
wie das in der deutschen Sprache möglich ist (Kriterium 2).
Er hat auch einen Input (die Zahl als binärkodiertes Wort, Kriterium 3)
und einen Output (0 oder 1, beziehungsweise falsch oder wahr),
der angibt, ob die Zahl (nicht) gerade ist (Kriterium 4).
Jeder seiner Einzelschritte ist einfach und durchführbar,
wir verlangen also keine unmöglichen Dinge (Kriterium 5).

Wenn wir für ein Problem einen Algorithmus angeben können,
dann ist das Problem \emph{berechenbar}.
Offensichtlich gibt es zu einem Problem mehr als einen Algorithmus,
der es löst, daher schließen sich auch interessante Fragen an:\footnote{Für diejenigen, die dies nicht so einfach akzeptieren wollen:
Sei ein Algorithmus A für ein Problem gegeben, dann ist der Algorithmus A', der wie A ist,
nur zusätzlich $1+1$ errechnet und das Ergebnis ignoriert,
auch eine Lösung für das Problem, aber von A unterschiedlich.}
Wie können wir den Aufwand für diese Algorithmen sinnvoll angeben?
Gibt es einen Algorithmus, der das Problem ``am besten'' löst?
Wie können wir beweisen, dass es keinen ``besseren'' Algorithmus gibt?
Diese Fragen werden wir in den folgenden Kapiteln beantworten.
Nun müssen wir uns zunächst die Frage stellen, wie wir Algorithmen angeben können,
damit die obigen Fragen sinnvoll und formal korrekt beantwortet werden können.

In der IT-Praxis werden Algorithmen in Programmen ausformuliert,
geschrieben in einer Programmiersprache.
Diese Programme sind \emph{Implementierungen} des Algorithmus.
Für einen Algorithmus kann es mehrere Implementierungen geben. 
Wir suchen für die Beantwortung der Fragen der theoretischen Informatik
eine Möglichkeit Algorithmen zu implementieren,
die es uns erlaubt die obigen Fragen zu beantworten.
Warum benutzen wir hierfür nicht einfach schon bekannte Programmiersprachen?
Fassen wir eine Programmiersprache als
Menge aller syntaktisch wohlgeformten Programme in dieser Sprache auf, 
haben wir als Gegenstand eine formale Sprache.
In diesem Fall wäre es also nicht notwendig,
ein neues Konzept einzuführen.
Allerdings sind Programmiersprachen für praktische Zwecke angelegt,
unser Fokus ist ein theoretischer:
Wir wollen mit Beweisen und Definitionen arbeiten
und hier ist es sinnvoller mit einem Formalismus zu arbeiten,
der ``einfacher'' ist als eine typische Programmiersprache.
% Hier noch eine Erläuterung für einfach?

Eine Möglichkeit,
die Implementierungen von Algorithmen in der theoretischen Informatik
anzugeben, sind \emph{Automaten}.
Ein Automat kann als eine abstrakte Maschine verstanden werden,
die einen Input bekommt, 
dabei mit simplen Einzelschritten läuft
und einen definiten Output liefert.
% TODO Bild.

Der Zusammenhang zwischen einer formalen Sprache und dem Automat kann so formuliert werden:
Ein Automat bekommt ein Wort als Input und entscheidet,
ob es zu der formalen Sprache gehört oder nicht.
Wenn eine formale Sprache ein Problem repräsentiert,
gibt der Automat also ein Verfahren an, 
wie das Problem gelöst werden kann.
Man kann auch sagen:
Der Automat ist eine Implementierung eines Algorithmus der das Problem löst.

\section{Deterministisch Finite Automaten}

Kommen wir noch einmal auf den Beispielsalgorithmus aus dem vorangegangen Abschnitt zurück.
Der Automat,
der unserem Algorithmus entspricht lässt sich graphisch so
wie in \autoref{fig:dfaeven} angeben.

\begin{figure}[ht] % ’ht’ tells LaTeX to place the figure ’here’ or at the top of the page
\centering % centers the figure
\begin{tikzpicture}
	\node[state, initial] (z1) {$z_1$};
	\node[state, accepting, right of=z1] (z0) {$z_0$};
	\draw (z1) edge[bend left, above] node{0} (z0)
	(z1) edge[loop above] node{1} (z1)
	(z0) edge[bend left, below] node{1} (z1)
	(z0) edge[loop above] node{0} (z0);
\end{tikzpicture}
\caption{Automat, der den naiven Algorithmus für EVEN implementiert.}
\label{fig:dfaeven}
\end{figure}


und überlegen uns, welche Komponenten der Automat haben muss,
um den genannten Algorithmus zu implementieren:
\begin{itemize}
    \item Teil es Automaten muss in jedem Fall eine Menge von Zeichen sein,
        aus denen die Inputwörter zusammengesetzt sind.
        Wir nennen diese Menge \emph{Eingabealphabet}
        und bezeichnen dieses wie bei den formalen Sprachen mit $\Sigma$,
        für unser Beispiel gilt $\Sigma = \{0,1\}$.

    \item Ein Automat hat eine Menge von \emph{Zuständen}, in denen er sich befindet.
        Der Automat, den wir suchen, scheint zwei Zustände zu haben:
        \begin{enumerate}
            \item Das letzte gelesene Zeichen war eine 1
                (oder wir haben noch kein Zeichen gelesen).
            \item Das letzte gelesene Zeichen war eine 0.
        \end{enumerate}
        Die Menge der Zustände eines Automaten bezeichnen wir mit $Z$.
        In unserem Fall ist $Z = \{z_1, z_0\}$.

    \item Während wir das Eingabewort lesen,
        kann sich der Zustand des Automaten ändern.
        Dies geben wir mit der \emph{Übergangsfunktion} $\delta$ an:
        $\delta: \Sigma \times Z \rightarrow Z$.
        In unserem Fall können wir $\delta$ so angeben:
        \begin{itemize}
            \item Lesen wir eine 0 und sind in Zustand $z_1$,
                dann gehen wir in Zustand $z_0$:\linebreak
                $[0,z_1,z_0]$
            \item Lesen wir eine 1 und sind in Zustand $z_1$,
                dann bleiben wir in Zustand $z_1$:\linebreak
                $[1,z_1,z_1]$
            \item Lesen wir eine 0 und sind in Zustand $z_0$,
                dann bleiben wir in Zustand $z_0$:\linebreak
                $[0,z_0,z_0]$
            \item Lesen wir eine 1 und sind in Zustand $z_0$,
                dann gehen wir in Zustand $z_1$:\linebreak
                $[1,z_0,z_1]$
        \end{itemize}
        Also ist $\delta = \{[0,z_1,z_0] [1,z_1,z_1] [0,z_0,z_0] [1,z_0,z_1]\}$

    \item Wir müssen noch angeben, in welchem Zustand der Automat ``startet'',
        der \emph{Anfangszustand} (allgemein bezeichnet mit $z_i$)
        ist in unserem Beispiel $z_1$.

    \item Als letztes müssen wir den Ausgabewert definieren,
        also ob der Automat das Wort akzeptiert oder nicht.
        Dies wird durch den Zustand definiert, indem sich der Automat
        befindet, wenn das letzte Zeichen gelesen wurde.
        Generell kann es mehr als einen akzeptierenden Zustand geben,
        daher geben wir die \emph{Endzustände} $E$ als Menge an,
        in unserem Beispiel: $E = \{z_0\}$.
\end{itemize}



In diesem Kapitel werden wir das \textbf{MATCH}-Problem genauer unter die Lupe nehmen
und dabei unseren ersten Automaten-Typ formal einführen.
Zur Wiederholung die User-Story-Version des \textbf{MATCH}-Problems:
\begin{center}
``Als Einkaufsmanager:in möchte ich, dass nur valide Lieferanten-IDs gespeichert werden
(beginnend mit einem ``L'', gefolgt von einer Zahl),
um Fehler in der Datenbank zu vermeiden.''
\end{center}
Abstrahieren und Formalisieren wir das Problem erscheint folgende informelle Formulierung
als mögliches Ergebnis:
\begin{itemize}
\item \textbf{Gegeben}: Eine Zeichenfolge (String)
\item \textbf{Gesucht}: Entspricht die Zeichenfolge einem bestimmten Muster?
\end{itemize}
Die gesuchte Funktion $f_{MATCH}$ hat als Definitionsmenge also eine Zeichenfolge
über einem Alphabet $\Sigma$ und als Wertemenge die booleschen Werte wahr/falsch,
bzw. 1/0: $f_{MATCH}: \Sigma \rightarrow \{0,1\}$.

Die informelle Version des Problems lässt schon vermuten,
dass seine Berechnung uns nicht vor große theoretische Probleme stellt.
Daher trägt dieses Kapitel auch den Titel ''Das Hello World der Automatentheorie'':
Hello-World-Programme sind einfache Code-Schnipsel,
um ein erstes und einfaches Programm einer Programmiersprache zum Laufen zu bringen
und den Ablauf kennenzulernen (Aufruf des Compilers/Interpreters, grundlegende Syntax, etc).
Analog wollen wir es mit der Automatentheorie halten:
\textbf{MATCH} ist einfach genug, um erste formale Konzepte einzuführen.



Für Match würde dies bedeuten, dass wir eine Sprache suchen,
die analog zu $f_{MATCH}$ genau die Kombinationen von Zeichenfolgen und booleschen Werten beinhaltet,
die anzeigen, ob die Zeichenfolge nun einem Muster entspricht oder nicht.

Wenn die Funktion, die wir formalisieren wollen, als Wertemenge die booleschen Werte hat,
können wir allerdings eine kleine Vereinfachung anwenden:
Das Entscheidungsproblem, also die Fragestellung, ob ein Wort zu einer Sprache gehört,
gibt ja schon einen booleschen Wert zurück.
Daher können wir die Wertemenge im Fall von \textbf{MATCH} als redundant ignorieren
und kommen zu folgender Sprache:
Alle Zeichenketten, die einem Muster entsprechen
(z.B. beginnend mit einem ''L'' gefolgt von einer Zahl).
In der Sprache $L_{MATCH}$ wären also z.B. 'L0101' oder 'L111',
nicht aber '1L1' oder 'abc'.

Im folgenden Abschnitt wollen wir uns formale Methoden anschauen,
wie wir eine solche Sprache erkennen können.


Viele formale Sprachen haben unendlich viele Wörter,
so auch $L_{MATCH}$.
Daraus folgt: wir können sie nicht einfach extensiv angeben (''aufzählen''),
sondern müssen Mittel und Wege finden, sie formal zu charakterisieren.
Zwei Methoden bieten sich an:
\begin{enumerate}
    \item Sprach-\emph{Generatoren}, d.h. Formalismen,
        mit denen alle Wörter einer Sprache abgeleitet werden können
        (und nicht mehr).
    \item Sprach-\emph{Akzeptoren}, d.h. Formalismen,
        die für eine gegebenes Wort entscheiden,
        ob es zur Sprache gehört (oder nicht).\footnote{
            Wie wir in \autoref{derBarbierUndDerLuegner} sehen werden,
            ist dieses ''oder nicht'' leider nicht so trivial.}
\end{enumerate}

Sprach-Generatoren sind nicht der Fokus dieses Skriptes, obwohl wir mit den Grammatiken
in \autoref{grammatiken} einen solchen Formalismus kennen lernen werden.\footnote{
Einige Lehrbücher der theoretischen Informatik bauen Ihren Stoff didaktisch anhand der Grammatiken
auf (sie erlauben die Sprachen hierarchisch zu klassifizieren).
Wer dieses Skript begleitend z.B. zu \cite{schoening} liest,
sollte diesen Unterschied präsent haben.}
Unser Fokus wird auf den Sprach-Akzeptoren liegen,
da sie sich gut für einen Problem-orientierten Ansatz eignen.

Was für einen Sprach-Akzeptor können wir also für $L_{MATCH}$ heranziehen?
Bühne frei für den Deterministisch Finiten Automaten (kurz: DFA).
Bevor wir DFAs formal einführen, wollen wir ihn informell motivieren: 
Ein Algorithmus, der das \textbf{MATCH}-Problem löst, könnte so aussehen:
\begin{enumerate}
    \item Lese das erste Zeichen $c_1$ des Inputs.
    \item wenn $z_1 \neq $ `$L$', gib 0 aus.
    \item Lese das nächste Zeichen $z_i$ des Inputs.
    \item Wenn $z_i \neq $ `$1$' oder $z_i \neq $ `$0$', gib 0 aus.
    \item Wenn der Input noch nicht zu Ende ist: Gehe zu Schritt 3.
    \item Gib 1 aus.
\end{enumerate}

%TODO Automatentheorie: Akzeptor vs Transduktor

\section{Minimalisierung}
\section{Reguläre Ausdrücke}


