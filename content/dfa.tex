\chapter{Reguläre Sprachen}

\section{Algorithmus und Implementierung}

In \autoref{einleitung} haben wir festgehalten:
Probleme lassen sich als als formale Sprachen repräsentieren.
Wie machen wir diese Formalisierung operabel,
also wie können wir \emph{Lösungen} für Probleme angeben?
In der Informatik nennen wir Problemlösungen \emph{Algorithmen}.
Wir suchen also nach einer geeigneten Repräsentation eines Algorithmus,
so dass wir auf den Überlegungen zu formalen Sprachen im letzten Kapitel aufbauen können.

Was genau ist aber ein Algorithmus?
Frei nach Donald E. Knuth (\cite{knuth1}, 4-6)
ist eine Algorithmus ist eine schrittweise Anweisung zur Lösung eines Problems,
welche die folgenden fünf Eigenschaften erfüllt:\footnote{
    In \cite{knuth1} (ebd.) finden wir auch eine Liste ähnlicher Begriffe:
    Rezept, Prozess, Methode, Technik, Prozedur oder Routine.
    Aber ein Algorithmus ist von diesen zu unterscheiden,
    auch wenn der Vergleich eine hilfreiche Verständnisanalogie sein kann.
}
\begin{enumerate}
    \item Seine Durchführung endet (``finiteness'').
    \item Er ist unmissverständlich formuliert (``definiteness'').
    \item Er hat einen (möglicherweise leeren) Input.
    \item Er liefert einen (möglicherweise komplexen) Output, abhängig vom Input.
    \item Er lässt sich durchführen (``effectiveness'').
\end{enumerate}

Das Kriterium 1 unterscheidet einen Algorithmus von einer Berechnungsmethode,
von der wir nicht wissen, ob sie für jeden gegebenen Input in endlichen Schritten einen
Output liefert.
Wir werden diesen Unterschied in \autoref{derBarbierUndDerLuegner} wieder aufgreifen.

Am besten diskutieren wir die Kriterien anhand eines ersten Beispiels.
Wir wollen einen Algorithmus angeben, der unser \textbf{EVEN}-Problem löst.
Dabei nutzen wir die Tatsache,
dass alle geraden Zahlen in der in \autoref{einleitung} eingeführten Kodierung
auf das Zeichen 0 enden.
Da wir noch keine geeignete Form für den Algorithmus identifiziert haben,
müssen wir den Algorithmus informell angeben:

\begin{enumerate}
    \item Lese das nächste Zeichen $a$, beginnend am linken Rand des Input-Wortes.
    \item Wenn $a$ das letzte Zeichen ist und $a = 1$, gib 0 (oder falsch) zurück.
    \item Wenn $a$ das letzte Zeichen ist und $a = 0$, gib 1 (oder wahr) zurück.
    \item Wenn $a$ nicht das letzte Zeichen ist, gehen zu Schritt 1.
\end{enumerate}

Der Algorithmus ist endlich (Kriterium 1),
denn er endet,
sobald das letzte Zeichen des Wortes gelesen wurde.
Er ist so unmissverständlich formuliert (Kriterium 2),
wie das in der deutschen Sprache möglich ist.
Er hat auch einen Input (die Zahl als binärkodiertes Wort, Kriterium 3)
und einen Output (0 oder 1, beziehungsweise falsch oder wahr, Kriterium 4).
Jeder seiner Einzelschritte ist prinzipiell durchführbar,
wir verlangen also keine unmöglichen Dinge Dinge (Kriterium 5).

Wenn wir für ein Problem einen Algorithmus angeben können,
dann ist das Problem \emph{berechenbar}.
Offensichtlich gibt es zu einem Problem mehr als einen Algorithmus,
der es löst, daher schließen sich auch interessante Fragen an:\footnote{Für diejenigen, die dies nicht so einfach akzeptieren wollen:
Sei ein Algorithmus A für ein Problem gegeben, dann ist der Algorithmus A', der wie A ist,
nur zusätzlich $1+1$ errechnet und das Ergebnis ignoriert,
auch eine Lösung für das Problem, aber von A unterschiedlich.}
Wie können wir den Aufwand für diese Algorithmen sinnvoll angeben?
Welchen Aufwand braucht der Algorithmus, der das Problem ``am besten'' löst?
Wie können wir beweisen, dass es keinen ``besseren Algorithmus'' gibt?

In der IT-Praxis werden Algorithmen in Programmen ausformuliert,
geschrieben in einer Programmiersprache.
Diese Programme sind \emph{Implementierungen} des Algorithmus.
Für einen Algorithmus kann es mehrere Implementierungen geben. 
Wir suchen für die Beantwortung der Fragen der theoretischen Informatik
eine Möglichkeit Algorithmen zu implementieren,
die es uns erlaubt die obigen Fragen zu beantworten.
Man könnte auch sagen, wir suchen eine geeignete Formalisierung für Algorithmen.

%Die Menge aller syntaktisch wohlgeformten Programme einer Programmiersprache
%können wir zwar auch als formale Sprache auffassen.
Eine Möglichkeit,
die Implementierungen von Algorithmen in der theoretischen Informatik
anzugeben, sind \emph{Automaten}.
Ein Automat kann als eine abstrakte Maschine verstanden werden,
die einen Input bekommt, 
dabei mit simplen Einzelschritten läuft
und einen definiten Output liefert.
% TODO Bild.
Wir haben also vier der fünf Kriterien für den Algorithmus abgedeckt.
Kriterium 1 (Endlichkeit des Laufs) wird uns im Laufe des Skriptes weiter beschäftigen.

Der Zusammenhang zwischen einer formalen Sprache und dem Automat kann so formuliert werden:
Ein Automat bekommt ein Wort als Input und entscheidet,
ob es zu der formalen Sprache gehört oder nicht.
Wenn eine formale Sprache ein Problem repräsentiert,
gibt der Automat also ein Verfahren an, 
wie das Problem gelöst werden kann.
Man kann auch sagen:
Der Automat ist eine Implementierung eines Algorithmus der das Problem löst.

Im folgenden wollen wir eine sehr einfache Art von Automaten einführen,
um diese einführenden Bemerkungen zu konkretisieren.

\section{Deterministisch Finite Automaten}
In diesem Kapitel werden wir das \textbf{MATCH}-Problem genauer unter die Lupe nehmen
und dabei unseren ersten Automaten-Typ formal einführen.
Zur Wiederholung die User-Story-Version des \textbf{MATCH}-Problems:
\begin{center}
``Als Einkaufsmanager:in möchte ich, dass nur valide Lieferanten-IDs gespeichert werden
(beginnend mit einem ``L'', gefolgt von einer Zahl),
um Fehler in der Datenbank zu vermeiden.''
\end{center}
Abstrahieren und Formalisieren wir das Problem erscheint folgende informelle Formulierung
als mögliches Ergebnis:
\begin{itemize}
\item \textbf{Gegeben}: Eine Zeichenfolge (String)
\item \textbf{Gesucht}: Entspricht die Zeichenfolge einem bestimmten Muster?
\end{itemize}
Die gesuchte Funktion $f_{MATCH}$ hat als Definitionsmenge also eine Zeichenfolge
über einem Alphabet $\Sigma$ und als Wertemenge die booleschen Werte wahr/falsch,
bzw. 1/0: $f_{MATCH}: \Sigma \rightarrow \{0,1\}$.

Die informelle Version des Problems lässt schon vermuten,
dass seine Berechnung uns nicht vor große theoretische Probleme stellt.
Daher trägt dieses Kapitel auch den Titel ''Das Hello World der Automatentheorie'':
Hello-World-Programme sind einfache Code-Schnipsel,
um ein erstes und einfaches Programm einer Programmiersprache zum Laufen zu bringen
und den Ablauf kennenzulernen (Aufruf des Compilers/Interpreters, grundlegende Syntax, etc).
Analog wollen wir es mit der Automatentheorie halten:
\textbf{MATCH} ist einfach genug, um erste formale Konzepte einzuführen.



Für Match würde dies bedeuten, dass wir eine Sprache suchen,
die analog zu $f_{MATCH}$ genau die Kombinationen von Zeichenfolgen und booleschen Werten beinhaltet,
die anzeigen, ob die Zeichenfolge nun einem Muster entspricht oder nicht.

Wenn die Funktion, die wir formalisieren wollen, als Wertemenge die booleschen Werte hat,
können wir allerdings eine kleine Vereinfachung anwenden:
Das Entscheidungsproblem, also die Fragestellung, ob ein Wort zu einer Sprache gehört,
gibt ja schon einen booleschen Wert zurück.
Daher können wir die Wertemenge im Fall von \textbf{MATCH} als redundant ignorieren
und kommen zu folgender Sprache:
Alle Zeichenketten, die einem Muster entsprechen
(z.B. beginnend mit einem ''L'' gefolgt von einer Zahl).
In der Sprache $L_{MATCH}$ wären also z.B. 'L0101' oder 'L111',
nicht aber '1L1' oder 'abc'.

Im folgenden Abschnitt wollen wir uns formale Methoden anschauen,
wie wir eine solche Sprache erkennen können.


Viele formale Sprachen haben unendlich viele Wörter,
so auch $L_{MATCH}$.
Daraus folgt: wir können sie nicht einfach extensiv angeben (''aufzählen''),
sondern müssen Mittel und Wege finden, sie formal zu charakterisieren.
Zwei Methoden bieten sich an:
\begin{enumerate}
    \item Sprach-\emph{Generatoren}, d.h. Formalismen,
        mit denen alle Wörter einer Sprache abgeleitet werden können
        (und nicht mehr).
    \item Sprach-\emph{Akzeptoren}, d.h. Formalismen,
        die für eine gegebenes Wort entscheiden,
        ob es zur Sprache gehört (oder nicht).\footnote{
            Wie wir in \autoref{derBarbierUndDerLuegner} sehen werden,
            ist dieses ''oder nicht'' leider nicht so trivial.}
\end{enumerate}

Sprach-Generatoren sind nicht der Fokus dieses Skriptes, obwohl wir mit den Grammatiken
in \autoref{grammatiken} einen solchen Formalismus kennen lernen werden.\footnote{
Einige Lehrbücher der theoretischen Informatik bauen Ihren Stoff didaktisch anhand der Grammatiken
auf (sie erlauben die Sprachen hierarchisch zu klassifizieren).
Wer dieses Skript begleitend z.B. zu \cite{schoening} liest,
sollte diesen Unterschied präsent haben.}
Unser Fokus wird auf den Sprach-Akzeptoren liegen,
da sie sich gut für einen Problem-orientierten Ansatz eignen.

Was für einen Sprach-Akzeptor können wir also für $L_{MATCH}$ heranziehen?
Bühne frei für den Deterministisch Finiten Automaten (kurz: DFA).
Bevor wir DFAs formal einführen, wollen wir ihn informell motivieren: 
Ein Algorithmus, der das \textbf{MATCH}-Problem löst, könnte so aussehen:
\begin{enumerate}
    \item Lese das erste Zeichen $c_1$ des Inputs.
    \item wenn $z_1 \neq $ `$L$', gib 0 aus.
    \item Lese das nächste Zeichen $z_i$ des Inputs.
    \item Wenn $z_i \neq $ `$1$' oder $z_i \neq $ `$0$', gib 0 aus.
    \item Wenn der Input noch nicht zu Ende ist: Gehe zu Schritt 3.
    \item Gib 1 aus.
\end{enumerate}
\section{Minimalisierung}
\section{Reguläre Ausdrücke}


