\chapter{Reguläre Sprachen}

\section{Algorithmus und Implementierung}

In \autoref{einleitung} haben wir festgehalten:
Probleme lassen sich als als formale Sprachen repräsentieren.
Wie machen wir diese Formalisierung operabel,
also wie können wir \emph{Lösungen} für Probleme angeben?
Wenn wir für ein Problem einen \emph{Algorithmus}\footnote{
    In \cite{knuth1} (ebd.) finden wir auch eine Liste ähnlicher Begriffe:
    Rezept, Prozess, Methode, Technik, Prozedur oder Routine.
    Ein Algorithmus ist von diesen zu unterscheiden,
    auch wenn Vergleiche als hilfreiche Verständnisanalogien dienen können.
}
angeben können, dann ist das Problem lösbar,
wir nennen es dann auch \emph{berechenbar}.
Was ist aber genau ein Algorithmus und wie geben wir ihn am besten an?
In der IT-Praxis werden Algorithmen in Programmen ausformuliert,
geschrieben in einer Programmiersprache.
Diese Programme nennt man \emph{Implementierungen} des Algorithmus.
Eine Implementierung ist also eine konkrete Realisierung des Algorithmus.\footnote{
    Ein Algorithmus (die ``Idee'') ist also von
    der Implementierung (die ``Realisierung'' der Idee) zu unterscheiden!
    Schon allein deshalb,
    weil ein Algorithmus mehrere Implmentierungen haben kann,
    sogar in einer Programmiersprache.}
Die Frage, was genau ein Algorithmus ist, ist aber noch nicht beantwortet.
Nach Donald E. Knuth (\cite{knuth1}, 4-6)
ist ein Algorithmus eine schrittweise Anweisung zur Lösung eines Problems,
welche die folgenden fünf Eigenschaften erfüllt:
\begin{enumerate}
    \item Seine Durchführung endet (``finiteness'').
    \item Er ist unmissverständlich formuliert (``definiteness'').
    \item Er hat einen (möglicherweise leeren) Input.
    \item Er liefert einen (möglicherweise komplexen) Output, abhängig vom Input.
    \item Er lässt sich durchführen (``effectiveness'').
\end{enumerate}

Kriterium 1 unterscheidet einen Algorithmus von einer \emph{Berechnungsmethode},
von der wir nicht wissen,
ob sie für jeden gegebenen Input in endlichen Schritten einen Output liefert.
Wir werden diesen Unterschied in \autoref{derBarbierUndDerLuegner} wieder aufgreifen.
Besonders klärungsbedürftig ist vielleicht das letzte Kriterium:
Was bedeutet es, dass sich ein Algorithmus durchführen lässt?
Dies ist dann der Fall, wenn jeder einzelne Schritt so einfach ist,
dass an seiner Durchführbarkeit kein Zweifel besteht.
Der Algorithmus ist dann einfach nur eine (endliche)
Abfolge durchführbarer Schritte.\footnote{Der Begriff der primitiven Rekursion
lässt sich mit einem ähnlichen Gedankengang motivieren (siehe \cite{schoening} 109ff).}

Neben Programmen einer Programmiersprache kann man auch
\emph{Automaten} spezifizieren,
um Algorithmen zu implementieren.
Ein Automat ist eine abstrakte Maschine,
die einen Input bekommt, 
dabei mit simplen Einzelschritten läuft
und einen definiten Output liefert.
Wir können uns damit Kriterium 5 gut vergegenwärtigen,
da wir uns einen Automaten erdenken,
dessen Bestandteile so einfach sind,
dass seine Wirkweise zweifelsfrei durchführbar ist:

\begin{itemize}
    \item Der Automat liest ein Wort $w \in \Sigma^*$ Zeichen für Zeichen
        (beginnend am ersten Zeichen, von links nach rechts, ohne dabei zu springen).
    \item Der Automat hat $n$ Zustände, in denen sie sich befinden kann.
    \item Wenn der Automat einen Buchstaben liest,
        dann kann sie in einen beliebigen Zustand wechseln oder im gleichen Zustand bleiben.
    \item Der Automat startet in genau einem der Zustände.
    \item Der Automat gibt durch seine Zustände an,
        ob er $w$ akzeptiert (Ausgabe 1 oder wahr),
        oder nicht (Ausgabe 0 oder falsch).
\end{itemize}

Der Zusammenhang zwischen einer formalen Sprache und dem Automat kann so formuliert werden:
Ein Automat bekommt ein Wort als Input und entscheidet über ein Outputsignal,
ob es zu der formalen Sprache gehört oder nicht.
Wenn eine formale Sprache ein Problem repräsentiert,
gibt der Automat also ein Verfahren an, 
wie das Problem gelöst werden kann.
Man kann auch sagen:
Der Automat ist eine Implementierung eines Algorithmus,
der das Problem löst.
Ein solcher Automat erfüllt die fünf Bedingungen von oben:
\begin{enumerate}
    \item Der Automat läuft nur so lange, wie das Inputwort Zeichen hat.
    \item Die Spezifikation des Automaten ist unmissverständlich.  
    \item Der Input ist das Inputwort.
    \item Der Output ist 0 oder 1 (akzeptierender oder nicht-akzeptierender Zustand).
    \item Der Automat lässt sich realisieren. 
\end{enumerate}

Bevor wir im nächsten Abschnitt den Automaten genauer fassen wollen,
erscheint eine Frage offensichtlich:
Warum nutzen wir nicht Programmiersprachen, um einen Algorithmus zu implementieren?
Warum also braucht es einen solchen Automaten?
Der Grund hierfür:
Wir suchen eine Möglichkeit Algorithmen zu implementieren,
die es uns erlaubt,
theoretische Fragen möglichst einfach zu beantworten:
\begin{itemize}
    \item Wie können wir den Aufwand sinnvoll angeben, den ein Algorithmus verursacht?
    \item Gibt es einen Algorithmus, der das Problem ``am besten'' löst?
    \item Können wir beweisen, dass es keinen ``besseren'' Algorithmus gibt?
\end{itemize}
Diese Fragen lassen sich mit Experimenten, also empirisch, nicht beantworten.
Wir müssen daher mit Beweisen und Definitionen arbeiten
und hier ist es sinnvoller mit einem Formalismus zu arbeiten,
der ``einfacher'' ist als eine typische Programmiersprache.
Um Programierer:innen bei ihrer Arbeit möglichst effizient zu unterstützen,
ist eine Programmiersprache typischerweise eher ausdrucksstark.
Der von von uns gesuchte Formalismus hat aber idealerweise nur wenige, einfache Bestandteile.
Damit gelingt es uns zum Beispiel schneller Kriterium 5 zu behandeln:
Wir müssen nur für wenige ``Bauteile'' einer Implementierung zeigen,
dass sie alle einfach und prinzipiell nutzbar sind.\footnote{
    Natürlich hat unser Formalismus letztlich eine Verbindung zu Programmiersprachen,
    diese wollen wir in \autoref{keller} und \autoref{ch:theorie} diskutieren.
}

Im folgenden Abschnitt wollen wir den Begriff des Automaten formal einführen
und ein Beispiel für einen Automaten angeben. 

% TODO Bild.
\section{Deterministisch Finite Automaten}

Formalismen, um Algorithmen anzugeben, gibt es viele.
Der Typ Automat, den wir im vorigen Kapitel informell eingeführt haben,
ist einer davon:
Der Deterministisch Finite Automate (DFA).\footnote{
    Wir folgen hier der englischen Literatur (Deterministic Finite Automaton),
    in deutschen Lehrbüchern findet man oftmals den Begriff
    Deterministischer Endlicher Automat (DEA).
}
Ganz allgemein können wir einen DFA A in der Sprache der Mengenlehre
als 5-Tupel (oder Quintupel angeben): $A = [\Sigma, Z, \delta, z_i, E]$:
\begin{itemize}
    \item $\Sigma$ ist das Eingabealphabet.
    \item Z ist die Menge der Zustände.
    \item $\delta: \Sigma \times Z \rightarrow Z$ ist die Übergangsfunktion.
    \item $z_i$ ist der Startzustand.
    \item $E$ ist die Menge der Endzustände.
\end{itemize}

Am besten geben wir ein Beispiel für einen Automaten an,
der ein uns bekanntes Problem löst,
also die entsprechende formale Sprache erkennt.
Wir nehmen hierfür die formale Sprache \textbf{EVEN} aus dem vorigen Kapitel her.
Neben der Angabe in der Sprache der Mengenlehre,
lassen sich Automaten auch sehr gut grafisch darstellen.
\autoref{fig:dfaeven} gibt einen DFA $A_{EVEN}$ an,
der \textbf{EVEN} erkennt.

\begin{figure}[ht] % ’ht’ tells LaTeX to place the figure ’here’ or at the top of the page
\centering % centers the figure
\begin{tikzpicture}
	\node[state, initial] (zi) {$z_i$};
	\node[state, accepting, above right of=zi] (z0) {$z_0$};
    \node[state, right of=z0] (zn) {$z_{NaN}$};
    \node[state, below right of=zi] (zo) {$z_{odd}$};
    \node[state, right of=zo] (ze) {$z_{even}$};
	\draw 
        (zi) edge[above] node{0} (z0)
        (zi) edge[below] node{1} (zo)
        (z0) edge[above] node{0,1} (zn)
        (zn) edge[loop above] node{0,1} (zn)
        (zo) edge[loop above] node{1} (zo)
        (zo) edge[bend left, above] node{0} (ze)
        (ze) edge[loop above] node{0} (ze)
        (ze) edge[bend left, above] node{1} (zo)
    ;
\end{tikzpicture}
\caption{DFA für EVEN}
\label{fig:dfaeven}
\end{figure}

Wir können alle Komponenten eines DFAs von einer solchen grafischen Darstellung ablesen:
\begin{itemize}
    \item $\Sigma$ ergibt sich aus den ausgehenden Pfeilen eines beliebigen Kreises.
    \item Z ist die Menge aller Kreise.
    \item $\delta$ ist durch alle Pfeile bestimmt.
    \item $z_i$ ist der Zustand,
        der von einem Pfeil erreicht wird,
        der nicht von einem anderen Zustand ausgeht. 
    \item Z sind alle Kreise mit doppeltem Umfang.
\end{itemize}

In der Sprache der Mengenlehre können wir die Komponenten so angeben:
\begin{itemize}
    \item Das Eingabealphabet $\Sigma = \{0,1\}$.
    \item Die Menge der Zustände Z = $\{z_i, z_0, z_{NaN}, z_{odd}, z_{even}\}$
    \item Die Übergangsfunktion $\delta$ wie in \autoref{tab:deltaeven} angegeben.
    \item Der Anfangszustand $z_i = z_i$.
    \item Die Menge der Endzustände E = $\{z_0, z_{even}\}$ 
\end{itemize}

\begin{table}[ht]
    \caption{$\delta$ für DFA $A_{EVEN}$}
    \centering
    \begin{tabular}{|c|c|c|}
    \hline
         $\downarrow$ Zustand \linebreak
         $\rightarrow$ Zeichen
        & 0
        & 1
        \\
        \hline
          $z_i$
        & $z_0$
        & $z_{odd}$
        \\
        \hline
          $z_i$
        & $z_0$
        & $z_{odd}$
        \\
        \hline
    \end{tabular}
    \label{tab:deltaeven}
\end{table}

Bevor wir die beiden Begriffe deterministisch und finit diskutieren,
wollen wir noch die graphische Spezifikation für Automaten kennenlernen. 
Der Automat,
der unserem Algorithmus entspricht lässt sich so wie in \autoref{fig:dfaeven} angeben.


Dabei entsprechen die Kreise den Zuständen,
die Pfeile definieren die Überangsfunktion,
ein freistehender Pfeil auf einen einzelnen Zustand bestimmt den Startzustand
und alle Kreise mit doppeltem Radius sind Endzustände.
Das Eingabealphabet lässt sich aus den Pfeilbeschriftungen ableiten.

Um zu verstehen, was determinstisch und finit genau bedeutet,
müssen wir ein paar Hilfskonzepte einführen:
\begin{itemize}
    \item Ein \emph{Schnappschuss} s eines DFA A ist ein geordnetes Paar $s = [z, w]$
        mit $z \in Z$ und $w \in \Sigma^*$.
        Ein Schnappschuss beschreibt,
        in welchem Zustand A ist und welches Wort A noch zu lesen hat.
        Nehmen wir den DFA von oben, dann wäre $[0010,z_1]$ ein Beispiel:
        Wir müssen noch $0010$ lesen und sind dabei in Zustand $z_1$.
    \item Eine \emph{Schnappschussfolge} S auf einem DFA A
        ist ein n-Tupel von Schnapp-schüssen. 
        Für jedes Paar aufeinanderfolgender Schnappschüsse $s_n$ und $s_{n+1}$ gilt,
        dass sie einen Übergang des Automaten A auf dem verbliebenen Restwort repräsentieren:
        \begin{itemize}
            \item $z_{n+1} = \delta(tw(w_{n},0,1), z_n)$
            \item $w_{n+1} = tw(w,1,|w|-1)$.
        \end{itemize}
        Zum Beispiel ist dies eine Schnappschussfolge für das obige Beispiel:\linebreak
        $[[0010,z_1],[010, z_0],[10, z_0],[0,z_1],[\epsilon,z_0]]$.
    \item Eine Schnappschussfolge $S = [s_0, \ldots s_{w-1}]$ auf A
        heißt \emph{Lauf} für $w$ auf A, wenn gilt:
        \begin{itemize}
            \item Wir haben $w$ als Input und starten beim Anfangszustand:
                $s_0 = [w,z_i]$ 
            \item Wir enden, wenn das Wort ``aufgebraucht'' ist:
                $s_{w-1} = [\epsilon, z]$ mit $z \in Z$,

        \end{itemize}
    \item Ein Lauf für w auf A heißt \emph{akzeptierend}, wenn gilt:
        $z_{w-1} \in E$,
        wenn der letzte Zustand des letzten Schnappschusses in der Schnappschussfolge
        ein Endzustand ist.
        Wir schreiben kurz: $w \rightarrow A,E$
        für ``der Lauf von w auf A ist akzeptierend''. 


\end{itemize}

Ein DFA A ist \emph{deterministisch}, weil es genau einen Lauf
für ein beliebiges Wort w gibt (der Lauf ist eindeutig determiniert).
Ein DFA A ist \emph{finit}, also endlich, weil der Lauf für jedes w auf A endlich ist.

Ein DFA A bestimmt also immer eine Sprache L aller der Wörter,
deren Lauf auf A akzeptierend ist.
Wir schreiben auch kurz: $L(A) = \{w|w \rightarrow A,E\}$.


Viele formale Sprachen haben unendlich viele Wörter,
so auch $L_{MATCH}$.
Daraus folgt: wir können sie nicht einfach extensiv angeben (''aufzählen''),
sondern müssen Mittel und Wege finden, sie formal zu charakterisieren.
Zwei Methoden bieten sich an:
\begin{enumerate}
    \item Sprach-\emph{Generatoren}, d.h. Formalismen,
        mit denen alle Wörter einer Sprache abgeleitet werden können
        (und nicht mehr).
    \item Sprach-\emph{Akzeptoren}, d.h. Formalismen,
        die für eine gegebenes Wort entscheiden,
        ob es zur Sprache gehört (oder nicht).\footnote{
            Wie wir in \autoref{derBarbierUndDerLuegner} sehen werden,
            ist dieses ''oder nicht'' leider nicht so trivial.}
\end{enumerate}

Sprach-Generatoren sind nicht der Fokus dieses Skriptes, obwohl wir mit den Grammatiken
in \autoref{grammatiken} einen solchen Formalismus kennen lernen werden.\footnote{
Einige Lehrbücher der theoretischen Informatik bauen Ihren Stoff didaktisch anhand der Grammatiken
auf (sie erlauben die Sprachen hierarchisch zu klassifizieren).
Wer dieses Skript begleitend z.B. zu \cite{schoening} liest,
sollte diesen Unterschied präsent haben.}
Unser Fokus wird auf den Sprach-Akzeptoren liegen,
da sie sich gut für einen Problem-orientierten Ansatz eignen.

%TODO Automatentheorie: Akzeptor vs Transduktor

\section{Minimalisierung}
\section{Reguläre Ausdrücke}

Aufgabe 1: Warum ist die Bezeichnung $Z_{NaN}$ in \autoref{fig:dfaeven} nicht ganz akkurat?
