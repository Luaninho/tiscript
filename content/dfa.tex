\chapter{Reguläre Sprachen}

\section{Algorithmus und Implementierung}

In \autoref{einleitung} haben wir festgehalten:
Probleme lassen sich als als formale Sprachen repräsentieren.
Wie machen wir diese Formalisierung operabel,
also wie können wir \emph{Lösungen} für Probleme angeben?
Wenn wir für ein Problem einen \emph{Algorithmus}\footnote{
    In \cite{knuth1} (ebd.) finden wir auch eine Liste ähnlicher Begriffe:
    Rezept, Prozess, Methode, Technik, Prozedur oder Routine.
    Ein Algorithmus ist von diesen zu unterscheiden,
    auch wenn Vergleiche als hilfreiche Verständnisanalogien dienen können.
}
angeben können, dann ist das Problem lösbar,
wir nennen es dann auch \emph{berechenbar}.
Was ist aber genau ein Algorithmus und wie geben wir ihn am besten an?
In der IT-Praxis werden Algorithmen in Programmen ausformuliert,
geschrieben in einer Programmiersprache.
Diese Programme nennt man \emph{Implementierungen} des Algorithmus.
Eine Implementierung ist also eine konkrete Realisierung des Algorithmus.\footnote{
    Ein Algorithmus (die ``Idee'') ist also von
    der Implementierung (die ``Realisierung'' der Idee) zu unterscheiden!
    Schon allein deshalb,
    weil ein Algorithmus mehrere Implmentierungen haben kann,
    sogar in einer Programmiersprache.}
Die Frage, was genau ein Algorithmus ist, ist aber noch nicht beantwortet.
Nach Donald E. Knuth (\cite{knuth1}, 4-6)
ist ein Algorithmus eine schrittweise Anweisung zur Lösung eines Problems,
welche die folgenden fünf Eigenschaften erfüllt:
\begin{enumerate}
    \item Seine Durchführung endet (``finiteness'').
    \item Er ist unmissverständlich formuliert (``definiteness'').
    \item Er hat einen (möglicherweise leeren) Input.
    \item Er liefert einen (möglicherweise komplexen) Output, abhängig vom Input.
    \item Er lässt sich durchführen (``effectiveness'').
\end{enumerate}

Kriterium 1 unterscheidet einen Algorithmus von einer \emph{Berechnungsmethode},
von der wir nicht wissen,
ob sie für jeden gegebenen Input in endlichen Schritten einen Output liefert.
Wir werden diesen Unterschied in \autoref{derBarbierUndDerLuegner} wieder aufgreifen.
Besonders klärungsbedürftig ist vielleicht das letzte Kriterium:
Was bedeutet es, dass sich ein Algorithmus durchführen lässt?
Dies ist dann der Fall, wenn jeder einzelne Schritt so einfach ist,
dass an seiner Durchführbarkeit kein Zweifel besteht.
Der Algorithmus ist dann einfach nur eine (endliche)
Abfolge durchführbarer Schritte.\footnote{Der Begriff der primitiven Rekursion
lässt sich mit einem ähnlichen Gedankengang motivieren (siehe \cite{schoening} 109ff).}

Neben Programmen einer Programmiersprache kann man auch
\emph{Automaten} spezifizieren,
um Algorithmen zu implementieren.
Ein Automat ist eine abstrakte Maschine,
die einen Input bekommt, 
dabei mit simplen Einzelschritten läuft
und einen definiten Output liefert.
Wir können uns damit Kriterium 5 gut vergegenwärtigen,
da wir uns einen Automaten erdenken,
dessen Bestandteile so einfach sind,
dass seine Wirkweise zweifelsfrei durchführbar ist:

\begin{itemize}
    \item Der Automat liest ein Wort $w \in \Sigma^*$ Zeichen für Zeichen
        (beginnend am ersten Zeichen, von links nach rechts, ohne dabei zu springen).
    \item Der Automat hat $n$ Zustände, in denen sie sich befinden kann.
    \item Wenn der Automat einen Buchstaben liest,
        dann kann sie in einen beliebigen Zustand wechseln oder im gleichen Zustand bleiben.
    \item Der Automat startet in genau einem der Zustände.
    \item Der Automat gibt durch seine Zustände an,
        ob er $w$ akzeptiert (Ausgabe 1 oder wahr),
        oder nicht (Ausgabe 0 oder falsch).
\end{itemize}

Der Zusammenhang zwischen einer formalen Sprache und dem Automat kann so formuliert werden:
Ein Automat bekommt ein Wort als Input und entscheidet über ein Outputsignal,
ob es zu der formalen Sprache gehört oder nicht.
Wenn eine formale Sprache ein Problem repräsentiert,
gibt der Automat also ein Verfahren an, 
wie das Problem gelöst werden kann.
Man kann auch sagen:
Der Automat ist eine Implementierung eines Algorithmus,
der das Problem löst.
Ein solcher Automat erfüllt die fünf Bedingungen von oben:
\begin{enumerate}
    \item Der Automat läuft nur so lange, wie das Inputwort Zeichen hat.
    \item Die Spezifikation des Automaten ist unmissverständlich.  
    \item Der Input ist das Inputwort.
    \item Der Output ist 0 oder 1 (akzeptierender oder nicht-akzeptierender Zustand).
    \item Der Automat lässt sich realisieren. 
\end{enumerate}

Bevor wir im nächsten Abschnitt den Automaten genauer fassen wollen,
erscheint eine Frage offensichtlich:
Warum nutzen wir nicht Programmiersprachen, um einen Algorithmus zu implementieren?
Warum also braucht es einen solchen Automaten?
Der Grund hierfür:
Wir suchen eine Möglichkeit Algorithmen zu implementieren,
die es uns erlaubt,
theoretische Fragen möglichst einfach zu beantworten:
\begin{itemize}
    \item Wie können wir den Aufwand sinnvoll angeben, den ein Algorithmus verursacht?
    \item Gibt es einen Algorithmus, der das Problem ``am besten'' löst?
    \item Können wir beweisen, dass es keinen ``besseren'' Algorithmus gibt?
\end{itemize}
Diese Fragen lassen sich mit Experimenten, also empirisch, nicht beantorten.
Wir müssen daher mit Beweisen und Definitionen arbeiten
und hier ist es sinnvoller mit einem Formalismus zu arbeiten,
der ``einfacher'' ist als eine typische Programmiersprache.
Um Programierer:innen bei ihrer Arbeit möglichst effizient zu unterstützen,
ist eine Programmiersprache typischerweise eher ausdrucksstark.
Der von von uns gesuchte Formalismus hat aber idealerweise nur wenige, einfache Bestandteile.
Damit gelingt es uns zum Beispiel schneller Kriterium 5 zu behandeln:
Wir müssen nur für wenige ``Bauteile'' einer Implementierung zeigen,
dass sie alle einfach und prinzipiell nutzbar sind.\footnote{
    Natürlich hat unser Formalismus letztlich eine Verbindung zu Programmiersprachen,
    diese wollen wir in \autoref{keller} und \autoref{ch:theorie} diskutieren.
}

Im folgenden Abschnitt wollen wir den Begriff des Automaten formal einführen
und ein Beispiel für einen Automaten angeben. 

% TODO Bild.
\section{Deterministisch Finite Automaten}
\begin{figure}[ht] % ’ht’ tells LaTeX to place the figure ’here’ or at the top of the page
\centering % centers the figure
\begin{tikzpicture}
	\node[state, initial] (z0) {$z_0$};
	\node[state, accepting, right of=z0] (z1) {$z_1$};
	\draw (z0) edge[bend left, above] node{0} (z1)
	(z0) edge[loop above] node{1} (z0)
	(z1) edge[bend left, below] node{1} (z0)
	(z1) edge[loop above] node{0} (z1);
\end{tikzpicture}
\caption{Automat, der den naiven Algorithmus für EVEN implementiert.}
\label{fig:dfaeven}
\end{figure}

Kommen wir noch einmal auf den (naiven) Beispielsalgorithmus
aus dem vorangegangen Abschnitt zurück
und überlegen uns, welche Komponenten der Automat haben muss,
um den genannten Algorithmus zu implementieren:
\begin{itemize}
    \item Wir brauchen eine Menge von Zeichen,
        aus denen die Inputwörter zusammengesetzt sind.
        Wir nennen diese Menge \emph{Eingabealphabet}
        und bezeichnen dieses wie bei den formalen Sprachen mit $\Sigma$,
        für unser Beispiel gilt $\Sigma = \{0,1\}$.

    \item Ein Automat hat eine Menge von \emph{Zuständen}, in denen er sich befindet.
        Unser Automat hat zwei Zustände:
        \begin{enumerate}
            \item Das letzte gelesene Zeichen war eine 1
                (oder wir haben noch kein Zeichen gelesen).
            \item Das letzte gelesene Zeichen war eine 0.
        \end{enumerate}
        Die Menge der Zustände eines Automaten bezeichnen wir mit $Z$.
        In unserem Fall ist $Z = \{z_1, z_0\}$.

    \item Während wir das Eingabewort lesen,
        kann sich der Zustand des Automaten ändern.
        Dies geben wir mit der \emph{Übergangsfunktion} $\delta$ an:
        $\delta: \Sigma \times Z \rightarrow Z$.
        In unserem Fall können wir $\delta$ so angeben:
        \begin{itemize}
            \item Lesen wir eine 0 und sind in Zustand $z_1$,
                dann gehen wir in Zustand $z_0$:\linebreak
                $[0,z_1,z_0]$
            \item Lesen wir eine 1 und sind in Zustand $z_1$,
                dann bleiben wir in Zustand $z_1$:\linebreak
                $[1,z_1,z_1]$
            \item Lesen wir eine 0 und sind in Zustand $z_0$,
                dann bleiben wir in Zustand $z_0$:\linebreak
                $[0,z_0,z_0]$
            \item Lesen wir eine 1 und sind in Zustand $z_0$,
                dann gehen wir in Zustand $z_1$:\linebreak
                $[1,z_0,z_1]$
        \end{itemize}
        Also ist $\delta = \{[0,z_1,z_0] [1,z_1,z_1] [0,z_0,z_0] [1,z_0,z_1]\}$

    \item Wir müssen noch angeben, in welchem Zustand der Automat ``startet'',
        der \emph{Anfangszustand} (allgemein bezeichnet mit $z_i$)
        ist in unserem Beispiel $z_1$.

    \item Als letztes müssen wir den Ausgabewert definieren,
        also ob der Automat das Wort akzeptiert oder nicht.
        Dies wird durch den Zustand definiert, indem sich der Automat
        befindet, wenn das letzte Zeichen gelesen wurde.
        Generell kann es mehr als einen akzeptierenden Zustand geben,
        daher geben wir die \emph{Endzustände} $E$ als Menge an,
        in unserem Beispiel: $E = \{z_0\}$.
\end{itemize}

Ganz allgemein können wir einen Automaten A in der Sprache der Mengenlehre
als 5-Tupel (oder Quintupel angeben): $A = [\Sigma, Z, \delta, z_i, E]$:
\begin{itemize}
    \item $\Sigma$ ist das Eingabealphabet.
    \item Z ist die Menge der Zustände.
    \item $\delta: \Sigma \times Z \rightarrow Z$ ist die Übergangsfunktion.
    \item $z_i$ ist der Startzustand.
    \item $E$ ist die Menge der Endzustände.
\end{itemize}
Einen solchen Automat nennen wir Deterministisch Finiten Automat (DFA).
Bevor wir die beiden Begriffe deterministisch und finit diskutieren,
wollen wir noch die graphische Spezifikation für Automaten kennenlernen. 
Der Automat,
der unserem Algorithmus entspricht lässt sich so wie in \autoref{fig:dfaeven} angeben.


Dabei entsprechen die Kreise den Zuständen,
die Pfeile definieren die Überangsfunktion,
ein freistehender Pfeil auf einen einzelnen Zustand bestimmt den Startzustand
und alle Kreise mit doppeltem Radius sind Endzustände.
Das Eingabealphabet lässt sich aus den Pfeilbeschriftungen ableiten.

Um zu verstehen, was determinstisch und finit genau bedeutet,
müssen wir ein paar Hilfskonzepte einführen:
\begin{itemize}
    \item Ein \emph{Schnappschuss} s eines DFA A ist ein geordnetes Paar $s = [z, w]$
        mit $z \in Z$ und $w \in \Sigma^*$.
        Ein Schnappschuss beschreibt,
        in welchem Zustand A ist und welches Wort A noch zu lesen hat.
        Nehmen wir den DFA von oben, dann wäre $[0010,z_1]$ ein Beispiel:
        Wir müssen noch $0010$ lesen und sind dabei in Zustand $z_1$.
    \item Eine \emph{Schnappschussfolge} S auf einem DFA A
        ist ein n-Tupel von Schnapp-schüssen. 
        Für jedes Paar aufeinanderfolgender Schnappschüsse $s_n$ und $s_{n+1}$ gilt,
        dass sie einen Übergang des Automaten A auf dem verbliebenen Restwort repräsentieren:
        \begin{itemize}
            \item $z_{n+1} = \delta(tw(w_{n},0,1), z_n)$
            \item $w_{n+1} = tw(w,1,|w|-1)$.
        \end{itemize}
        Zum Beispiel ist dies eine Schnappschussfolge für das obige Beispiel:\linebreak
        $[[0010,z_1],[010, z_0],[10, z_0],[0,z_1],[\epsilon,z_0]]$.
    \item Eine Schnappschussfolge $S = [s_0, \ldots s_{w-1}]$ auf A
        heißt \emph{Lauf} für $w$ auf A, wenn gilt:
        \begin{itemize}
            \item Wir haben $w$ als Input und starten beim Anfangszustand:
                $s_0 = [w,z_i]$ 
            \item Wir enden, wenn das Wort ``aufgebraucht'' ist:
                $s_{w-1} = [\epsilon, z]$ mit $z \in Z$,

        \end{itemize}
    \item Ein Lauf für w auf A heißt \emph{akzeptierend}, wenn gilt:
        $z_{w-1} \in E$,
        wenn der letzte Zustand des letzten Schnappschusses in der Schnappschussfolge
        ein Endzustand ist.
        Wir schreiben kurz: $w \rightarrow A,E$
        für ``der Lauf von w auf A ist akzeptierend''. 


\end{itemize}

Ein DFA A ist \emph{deterministisch}, weil es genau einen Lauf
für ein beliebiges Wort w gibt (der Lauf ist eindeutig determiniert).
Ein DFA A ist \emph{finit}, also endlich, weil der Lauf für jedes w auf A endlich ist.

Ein DFA A bestimmt also immer eine Sprache L aller der Wörter,
deren Lauf auf A akzeptierend ist.
Wir schreiben auch kurz: $L(A) = \{w|w \rightarrow A,E\}$.


Viele formale Sprachen haben unendlich viele Wörter,
so auch $L_{MATCH}$.
Daraus folgt: wir können sie nicht einfach extensiv angeben (''aufzählen''),
sondern müssen Mittel und Wege finden, sie formal zu charakterisieren.
Zwei Methoden bieten sich an:
\begin{enumerate}
    \item Sprach-\emph{Generatoren}, d.h. Formalismen,
        mit denen alle Wörter einer Sprache abgeleitet werden können
        (und nicht mehr).
    \item Sprach-\emph{Akzeptoren}, d.h. Formalismen,
        die für eine gegebenes Wort entscheiden,
        ob es zur Sprache gehört (oder nicht).\footnote{
            Wie wir in \autoref{derBarbierUndDerLuegner} sehen werden,
            ist dieses ''oder nicht'' leider nicht so trivial.}
\end{enumerate}

Sprach-Generatoren sind nicht der Fokus dieses Skriptes, obwohl wir mit den Grammatiken
in \autoref{grammatiken} einen solchen Formalismus kennen lernen werden.\footnote{
Einige Lehrbücher der theoretischen Informatik bauen Ihren Stoff didaktisch anhand der Grammatiken
auf (sie erlauben die Sprachen hierarchisch zu klassifizieren).
Wer dieses Skript begleitend z.B. zu \cite{schoening} liest,
sollte diesen Unterschied präsent haben.}
Unser Fokus wird auf den Sprach-Akzeptoren liegen,
da sie sich gut für einen Problem-orientierten Ansatz eignen.

%TODO Automatentheorie: Akzeptor vs Transduktor

\section{Minimalisierung}
\section{Reguläre Ausdrücke}
