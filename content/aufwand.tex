\chapter{Aufwand}
Das Thema dieses Kapitels lässt sich mit einer Frage zusammenfassen:
Wie bemessen wir den Aufwand,
den ein implementierter Algorithmus benötigt, um ein Problem zu lösen?
In \autoref{einleitung} haben wir formale Sprachen als Repräsentation von Problemen eingeführt,
in \autoref{turing} wurde eine Möglichkeit eingeführt,
alle bekannten Algorithmen zu implementieren,
die Turingmaschine.
Dieser Formalismus erlaubt es uns,
den Aufwand einer spezifischen Berechnung zu quantifizieren,
und den Aufwand eines Algorithmus anzugeben.

\section{Effizienz in Zeit (und Raum)}

Was meinen wir, wenn wir von Aufwand oder Effizienz einer Berechnung sprechen?
Meist wird als erstes die Zeit genannt,
die es braucht,
damit eine Berechnung ein Ergebnis liefert.
Den Speicherplatz,
den eine Implementierung benötigt,
um den Input,
eventuelle Zwischenergebnisse
und den Output zu speichern,
kann man ebenfalls anführen.
Beides, Zeit und ``Raum'' sind valide Größen,
anhand derer wir Aufwand oder Effizienz bemessen können.

Wir werden uns in diesem Skript auf Zeit-Effizienz beschränken,
weswegen wir bei Aufwand beziehungsweise Effizienz immer von
zeitlichem Aufwand beziehungsweise zeitlicher Effizienz sprechen.
Allerdings kann vieles auf Raum-Effizienz übertragen werden,
das wir in diesem Kapitel entwickeln.

Wir wollen über diese drei folgenden Schritte zu einem Verständnis von Aufwand zu kommmen:
\begin{itemize}
    \item Aufwand für einen Lauf einer spezifischen Turingmaschine auf einem spezifischen Wort.
    \item Abschätzung für die Länge von Läufen einer spezifischen Turingmaschine
        auf allen Worten einer Sprache.
    \item Schranken für die Länge aller Turingmaschinen, die eine spezifische Sprache erkennen.
\end{itemize}

Die folgenden Abschnitte hangeln sich an diesen Schritten entlang.

\subsection{Aufwand eines spezfischen Laufs}

\begin{itemize}
    \item Das konkrete Problem, gegeben als \emph{formale Sprache L}.
    \item Die konkrete Problemstellung, gegeben als \emph{Wort $w \in L$}.
    \item Den konkreten Algorithmus, implementiert als \emph{Turingmaschine tm}.
\end{itemize}

Dies sind formal korrekt eingeführte Konzepte
und wir können Zeit und Platzaufwand daran genau definieren.

$time: \Sigma^* \times TM \rightarrow \mathbb{N}$ ist die Funktion,
die für ein Wort $w \in \Sigma^*$ den Zeitaufwand auf einer Turingmaschine TM angibt.
Wir legen fest: $time(w,A) =  length(l_{w,TM}) = |w|$.
        
       

\subsection{Abschätzung des Aufwandes aller Läufe}

Bisher haben wir aber nur über den Aufwand gesprochen,
den ein \emph{Wort} verursacht,
nicht aber über den Aufwand,
den ein ganzes Problem, also eine Menge von Wörtern,
also eine \emph{formale Sprache} verursacht.
Wenn wir die Effizienz einer Problemlösung angeben,
haben wir prinzipiell drei Szenarien im Kopf:
\begin{itemize}
    \item \textbf{Best Case}: Wir wählen das Wort aus der formalen Sprache aus,
        für das der Algorithmus die geringste Zeit
        beziehungsweise den geringsten Platz benötigt.
        Wir betrachten also das Minimum von $time$ beziehungsweise $space$.
    \item \textbf{Average Case}: Wir nutzen statistische Methoden, um die wahrscheinlichste
        Dauer bzw. den wahrscheinlichsten Speicherplatzbedarf eines beliebigen Wortes aus
        der formalen Sprache zu quantifizieren.
        Wir betrachten also zum Beispiel das arithmetische Mittel von $time$ beziehungsweise
        $space$.\footnote{Der Median wäre ein weiteres Lagemaß, dass genutzt werden kann,
        oder wir achten auf die Standardabweichung (Streuungsmaß), oder auf eine Kombination 
        mehrerer Maße, was die einfache Vergleichbarkeit von Algorithmen wiederum erschwert.}
    \item \textbf{Worst Case}: Wir wählen das Wort aus der formalen Sprache aus,
        für das der Algorithmus die meiste Zeit bzw. den meisten Platz benötigt.
        Wir betrachten also das Maximum von $time$ beziehungsweise $space$.
\end{itemize} 

Da der Best Case meist wenig Aussagekraft über die Güte des Algorithmus besitzt,
wird er selten als Maß für den Aufwand eines Problems genutzt.
Am aussagekräftigsten ist der Average Case,
aber um ihn formal sauber anzuwenden braucht es
entsprechendes statistisches Werkzeug.\footnote{
    Für interessierte Leser:innen sei \cite{knuth1}, 96ff bzw. 1.2.10 empfohlen,
    hier spielt Knuth die probabilistische Analyse eines recht simplen Algorithmus durch.} 
Da dies den Rahmen des Skriptes sprengen würde,
konzentrieren wir uns auf den Worst Case.
Wir vereinbaren also: Wenn wir vom Aufwand eines Problems sprechen,
sprechen wir dabei stets vom Worst Case.

\subsection{Untere und Obere Schranken für den Aufwand}
Mit $time$ und $space$ und dem Worst Case-Wert können wir Aussagen über den Aufwand treffen,
den ein bestimmter Algorithmus für ein bestimmtes Problem verursacht.
Wir treffen allerdings keine Aussagen darüber,
wie viel Aufwand das Problem \emph{an sich} erzeugt.
Dazu müssten wir Aussagen über alle prinzipiell \emph{möglichen} Algorithmen treffen,
die das Problem lösen
und über alle formale Sprachen, die das Problem repräsentieren:
Den Aufwand eines Problems würden wir dann mit dem effizientestem Algorithmus 
auf einer der Repräsentationen gleichsetzen.
Oftmals ist der Nachweis sehr schwer, ob es (k)einen effizienteren Algorithmus
für ein Problem gibt.
Den aktuellen Stand der Forschung erlernt man typischer Weise in Vorlesungen über
Algorithmen und Datenstrukturen.

\section{Landau und Big-O: Wachstum}
\section{Messen vs. Beweisen}\label{messenVsBeweisen}

