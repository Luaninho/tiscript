\chapter{Einleitung}\label{einleitung}
%\section{Warum theoretische Informatik?}
Warum lohnt sich die Beschäftigung mit theoretischer Informatik?
Die kurze Antwort: Sie liefert einen wesentlichen Teil des Handwerkszeugs,
um die Potentiale und Grenzen der technischen Informationsverarbeitung zu verstehen.
Die lange Antwort soll dieses Skript geben.

Die Nützlichkeit eines Werkzeugs leuchtet dann ein,
wenn es hilft Probleme zu lösen.
Daher ist der Problembegriff im Mittelpunkt dieses Skripts.
Was also ist ein Problem im Sinne der theoretischen Informatik?

\section{Probleme}

Alltägliche IT-Aufgaben werden oft als Userstories dokumentiert.
Eine Userstory wird in der agilen Softwareentwicklung genutzt um Anforderungen zu spezifizieren.
Eine Userstory trifft man typischerweise in diesem Format an:
''Als \textless Rolle\textgreater\ möchte ich \textless Feature\textgreater,
um \textless Ziel\textgreater\ zu erreichen.''
Diese Beispiele für Userstories sollen uns im Skript begleiten:

\begin{itemize}
    \item \textbf{U\textsubscript{EVEN}}: Als Kommisionier:in
         möchte ich die Anzahl der geplanten Paletten pro LKW kennen,
         um zu sehen, ob Platz für den Hubwagen bleibt. 
% TODO: Einkommentieren und Bearbeiten, wenn das jeweilige Kapitel geschrieben ist.
%        kennen, um meine Lieferungen zu optimieren.
%    \item \textbf{MATCH}: Als Einkaufsmanager:in möchte ich,
%        dass nur valide Lieferanten-IDs gespeichert werden
%        (beginnend mit einem ``L'', gefolgt von einer Zahl),
%        um Fehler in der Datenbank zu vermeiden.
%    \item \textbf{HALT}: Als Product Owner des Serverless-Computings möchte ich,
%        dass nur terminierende Code-Snippets deployt werden,
%        um die verfügbaren Ressourcen effizient zu nutzen.
%    \item \textbf{ROUTE}: Als Kommissionierer:in möchte ich,
%        dass morgens die optimalen Routen für die LKWs in die 24 Filialen berechnet werden,
%        um die Lieferzeit zu minimieren.
%    \item \textbf{QUANTUMSEC}: Als Chief Security Officer möchte ich,
%        dass die firmen-interne Kommunikation quantensicher verschlüsselt wird,
%        um die Vertraulichkeit der Absprachen zu garantieren.
\end{itemize}

Erfahrene und kompetente IT-Fachkräfte identifizieren beim ersten Lesen einer Userstory
einen logischen ``Kern'',
also etwas das in unterschiedlichem Gewand in der Praxis wieder- und wiederkehrt.
Diesen Kern wollen wir als ``Problem'' bezeichnen,
bis wir eine bessere Definition dieses Begriffs finden.
Mit den Methoden der theoretischen Informatik ausgerüstet,
kann man einiges über die Userstories und deren zugrundeliegende Probleme sagen:
\begin{itemize}
    \item Mindestens eine Userstory ist leicht zu realisieren.
    \item Für mindestens eine Userstory kann man mit vertretbarem Aufwand nur suboptimale Lösungen finden.
    \item Mindestens eine Userstory ist nicht umsetzbar.
\end{itemize}
Um unnötige Arbeit zu vermeiden
und die besten der bekannten Lösungen zu implementieren,
ist natürlich von Interesse,
welche Userstory in welche Kategorie fällt.
Dafür müssen wir die Ergebnisse und Werkzeuge
der theoretischen Informatik kennen und anwenden;
die Form der Userstory ist jedoch dafür nicht geeignet.
Damit wir das volle Potential der theoretischen Informatik schöpfen können,
müssen wir zwei Schritte gehen:
Wir müssen von den Userstories \emph{abstrahieren}
und diese Abstraktion \emph{formalisieren}.
Die beiden folgenden Abschnitte zeigen anhand \textbf{U\textsubscript{EVEN}}
beispielhaft, was damit gemeint ist.
Dabei werden wir die ersten zentralen Begriffe dieses Skriptes einführen und diskutieren.
\section{Abstraktion}

\emph{Abstraktion} ist die ausschließliche Betrachtung der Aspekte eines Sachverhalts,
die für einen gegebenen Zweck wesentlich sind.
Die Abstraktion ist der Weg von einer sehr speziellen Aufgabenbeschreibung,
wie einer Userstory, zu einem abstrakten Problem,
dessen Lösung in vielen spezifischen Kontexten anwendbar wird.
Im besten Fall ist diese Lösung bereits implementiert, frei verfügbar 
und daher leicht nachnutzbar.

Es gibt leider keinen einfachen, eindeutigen oder automatisierbaren Weg
duch Abstraktion von einer Userstory zu einem abstrakten Problem zu kommen.
Dafür sind intellektuelle Kreativität
und ein gutes Verständnis des vorliegenden Zwecks notwendig.
Ein möglicher Fehler ist zum Beispiel,
zu wenige Aspekte auszulassen,
so dass das abstrakte Problem nicht so einfach wie möglich ist. 
Ebenso ist es ein Fehler, zu viele Aspekte auszulassen,
so dass das abstrakte Problem nicht so detailreich wie nötig ist,
um dem vorliegenden Zweck gerecht zu werden.
Unser vorliegender Zweck ist die Einteilung der Userstories anhand deren Lösbarkeit.
So könnte eine Abstraktion von \textbf{U\textsubscript{EVEN}} für diesen Zweck aussehen:
\begin{enumerate}
    \item \emph{Als Kommisionier:in
         möchte ich die Anzahl der geplanten Paletten pro LKW kennen,
         um zu sehen, ob Platz für den Hubwagen bleibt.
        } (ursprüngliche Userstory).
    \item \emph{Identifikation der Anzahl an Paletten, um verfügbaren Platz zu quantifzieren.}
        (Wer die Anzahl kennen will und wofür der Platz gedacht ist,
        ist für unseren Zweck gleichgültig.)
    \item \emph{Ist die Anzahl an Paletten (un)gerade?}
        (Es ist z.B. egal,
        ob zwei, drei oder mehr Paletten pro LKW nebeneinander passen,
        Hauptsache es bleibt Platz.)
    \item \emph{Ist eine Zahl gerade?}
        (Es ist egal, ob wir dies für Paletten oder andere Objekte entscheiden.)
\end{enumerate}

Wie wir im Laufe des Skriptes sehen werden, ist die letzte Formulierung des Problems die 
wesentliche Vorstufe, um die Methoden der theoretischen Informatik anzuwenden.\footnote{
Es ist natürlich möglich,
dass die gezeigten Schritte nicht das richtige Resultat für einen anderen Zweck liefert.
Für eine Kommissionierer:in mag die Anzahl noch aus anderen Gründen interessant sein,
z.B. um die Auslastung der LKWs zu bewerten und zu optimieren.
Oder es mag nicht gleichgültig sein, ob zwei, drei oder mehr Paletten nebeneinander passen.
Wie man Abstraktionen im Sinne der Software Entwicklung einsetzen kann,
lehrt die Disziplin des Software Engineerings.}
Wir kommen so auf den Kern der Userstory \textbf{U\textsubscript{EVEN}},
den wir \textbf{I\textsubscript{EVEN}} nennen wollen:
\begin{itemize}
    \item \textbf{Gegeben:} Eine Zahl
    \item \textbf{Gesucht:} Ein Wahrheitswert, der anzeigt, ob die Zahl gerade ist. 
\end{itemize}
Diese Form der Problemangabe (Gegeben/Gesucht) bezeichnen wir als \emph{informell}
(daher das I).
Dabei ist für die informelle Angabe wichtig,
sowohl den Typ des (potentiell komplexen) Eingabewerts (hier: eine Zahl),
als auch des (potentiell komplexen) Ausgabewerts (hier: ein Wahrheitswert) zu spezifizieren.
Generell kommen wir aus der informellen Angabe eines Problems recht unkompliziert zum Schluss,
dass sich ein Problem als Funktion beschreiben lässt,
also als Zuordnung von den ``Eingabewerten'' im Gegeben-Teil
(also der Definitionsmenge),
zu den ``Ausgabewerten'' im Gesucht-Teil
(der Wertemenge).

Die Fähigkeit via Abstraktion von vielen Alltagsaufgaben zu informellen Problemen zu kommen,
macht kompetenten IT-Fachkräfte das Leben leichter:
Die Lösungen für wiederkehrenden Probleme können
in Libraries, Best Practices und Dokumentationen festgehalten oder gar gefunden werden.
So sind Schablonen parat,
um schnell und effizient zu guten Ergebnissen zu kommen.

Aber die theoretische Informatik spielt hierbei keine explizite Rolle.
Ihre Methoden sind formal,
daher wird die formalisierten Version von \textbf{I\textsubscript{EVEN}} benötigt,
also \textbf{EVEN}.
Warum sollten wir diesen zusätzlichen Schritt gehen?
Die kurze Antwort:
Wir können über die Expertise erfahrener IT-Fachkräfte hinausgehen
und zweifelsfrei \emph{beweisen},
dass manche Probleme einfach, aufwändig oder unlösbar sind.\footnote{
    Eine etwas längere Antwort geben wir in \autoref{messenVsBeweisen}.
}
Wir stellen also daher drei Fragen exemplarisch für \textbf{EVEN},
die sich prinzipiell aber für alle Probleme ergeben:
\begin{enumerate}
    \item Wie muss \textbf{EVEN} dargestellt sein, damit eine Maschine es lösen kann?\\ 
        In anderen Worten: Wie kann \textbf{EVEN} \emph{formalisiert} werden? 
    \item Wie effizient kann eine Maschine \textbf{EVEN} lösen?\\
        In anderen Worten: Wie \emph{komplex} ist \textbf{EVEN}?
    \item Kann eine Maschine \textbf{EVEN} überhaupt lösen?\\
        In anderen Worten: Ist \textbf{EVEN} \emph{berechenbar}?  
\end{enumerate}
Drei grundlegende Teildisziplinen der theoretischen Informatik
geben Antwort auf diese Art der Fragen:
\begin{enumerate}
    \item Die \textbf{Theorie der formalen Sprachen und Automaten}
    \item Die \textbf{Komplexitätstheorie}
    \item Die \textbf{Berechenbarkeitstheorie}
\end{enumerate}
Im Laufe des Skriptes werden wir
in grundlegende Ergebnisse dieser drei Teildisziplinen einführen,
ihre Wechselwirkung beschreiben
und Konsequenzen für die eingangs erwähnten Userstories ziehen.

\section{Formalisierung}\label{sec:formalisierung}

Damit wir die Werkzeuge der theoretischen Informatik anwenden können,
werden wir Probleme wie \textbf{EVEN} als formale Sprachen repräsentieren.
Um zu verstehen, warum dies sinnvoll ist,
werden wir in drei Schritten vorgehen:
\begin{enumerate}
    \item Erklären, was eine formale Sprache ist (\autoref{subsec:formaleSprachen})
    \item Mit \textbf{I\textsubscript{EVEN}} beispielhaft zeigen,
        wie man ein informelles Problem in eine formale Sprache übersetzen kann 
        (\autoref{subsec:problemeAlsFormaleSprachen})
    \item Diskutieren, warum formale Sprachen geeignete Repräsentationen für Probleme sind
        (\autoref{subsec:warumFormaleSprachen})
\end{enumerate}

\subsection{Formale Sprachen}\label{subsec:formaleSprachen}

Eine formale Sprache ist eine Menge von Worten,
die über einem Zeichenalphabet gebildet werden.
In diesem Abschnitt dröseln wir diesen Satz Schritt für Schritt auf:
Von Zeichen, über Worte, bis hin zu formalen Sprachen.

\subsubsection{Zeichen}

Eine Menge von Zeichen bezeichnen wir als \emph{Alphabet}, kurz: $\Sigma$.
Zum Beispiel wäre das kanonische Alphabet für die meisten IT-Systeme: $\Sigma = \{0,1\}$.\\

\noindent
Wir verwenden diese Variablen für Zeichen: $a,b,c$;
wenn wir diese Buchstaben verwenden und nichts anderes angeben,
gilt implizit: $a, b, c \in \Sigma$ für ein gegebenes $\Sigma$.\footnote{
Wenn $\Sigma$ nicht explizit angegeben oder aus dem Kontext herleitbar ist,
wird $\Sigma$ also auch als Variable für ein beliebiges Alphabet verwendet.}\\

\noindent
Eine Operation auf Zeichen ist die \emph{Konkatenation},
also die Verbindung von zwei Zeichen, z.B. $01$.
Wie bei der Multiplikation mit Variablen in der Mathematik üblich,
wird die Konketanation nicht explizit mit einem eigenen Zeichen repräsentiert.

\subsubsection{Worte}
Das Ergebnis einer beliebig oft ausgeführten Konkatenation,
also eine Zeichenfolge,
bezeichnen wir als \emph{Wort}, z.B.: $110$\\

\noindent
Die Menge aller Wörter,
die sich aus einem Alphabet bilden lassen,
bezeichnen wir als \emph{Kleenesche Hülle}, dargestellt als Stern: $\Sigma^*$.\\

\noindent
Wir verwenden diese Variablen für Worte:
$u, v, w, x, y, z$; wenn wir diese Buchstaben verwenden und nichts anderes angeben,
gilt implizit: $u, v, w, x, y, z \in \Sigma^*$.\\

\noindent
Die \emph{Länge} eines Wortes ist die Anzahl seiner Zeichen.
Formal benutzen wir die Betragsstriche um ein Wort, um seine
Länge zu bezeichnen. Wenn z.B. $w = 110$, dann gilt $|w| = 3$.\\

\noindent
Das Wort mit der Länge 0, also das Wort, dass aus null Zeichen besteht,
nennen wir das \emph{leere Wort}, kurz: $\epsilon$.
Es gilt $|\epsilon| = 0$.\\

\noindent
Für ein Wort $w$ mit $|w| > 1$ bezeichnet $w_i$ mit $0 \leq i < n$
genau das Zeichen in $w$ an der i-ten Stelle.
Sei zum Beispiel $w = 101$, dann ist $w_1 = 0$ (der Index ist null-basiert).\\

\noindent
Für die n-malige Wiederholung eines Zeichens oder Wortes führen wir den \emph{Wiederholungsoperator}
ein, eine hochgestellte Zahl $n \in \mathbb{N}$: $a^n$ oder $w^n$.
Z.B. $0^3 = 000$ und $(10)^2 = 1010$.
$a^0$ bzw. $w^0$ entspricht dabei $\epsilon$.\\

\noindent
Wollen wir angeben, dass ein Zeichen oder Wort beliebig oft (also auch 0-mal) wiederholt
wird, nutzen wir dafür einen hochgestellten Stern, den \emph{Kleene-Operator} $a^*$ oder $w^*$.
Mit dem Kleene-Operator bezeichnen wir immer eine unendliche Menge von Wörtern, z.B.:
$a^* = \{\epsilon, a, aa, aaa, aaaa, \dots\}$

\subsubsection{Formale Sprachen als Menge von Worten}

Bevor wir den Begriff der formalen Sprachen ordentlich einführen,
ist noch eine Warnung angebracht:
Während die Verwendung des Begriffs ''Zeichens''
noch recht intuitiv mit dem Begriff des Buchstaben zusammenfällt
(zumindest im deutschsprachigen Raum),
ist schon der formal eingeführte Wort-Begriff eher eine Zumutung für unsere Intuition:
Worte im Sinne des vorangegangenen Abschnitts sind einfach Zeichenfolgen,
egal ob sie aussprechbar oder im Kontext einer natürlichen Sprache
(wie deutsch oder englisch) einen Sinn ergeben.

%Man müsste also eigentlich das natursprachliche $Wort_N$ von dem formalen $Wort_F$ trennen,
%das wir oben eingeführt haben.
%Eine Crux aller formal arbeitenden Wissenschaften ist,
%dass die Menge an Zeichen und Begriffen begrenzt ist und daher Doppeldeutigkeiten auftreten.
%Wir müssen also durch Konventionen klären, welche Bedeutung wir einem Begriff geben wollen:
%Im Kontext dieses Skriptes bezeichnen wir mit dem Begriff Wort die Zeichenfolge, also $Wort_F$.
%Sollte dies nicht der Fall sein und der Kontext nicht ausreichen,
%um zwischen beiden Bedeutungen zu unterscheiden,
%werden wir die subskribierten Varianten verwenden.

Diese Überlegung trifft nicht nur auf Worte, sondern auch auf \emph{Sprachen} zu.
\textbf{Eine Sprache im Sinne der theoretischen Informatik ist einfach eine Menge von Worten.}
Z.B. ist $L = \{0, 1, 00, 01, 10, 11 \}$ die Sprache der Worte,
die aus einem oder zwei Binärzeichen bestehen.
Eine formale Sprache ist also als \emph{Menge} im Sinne der Mengenlehre aufzufassen, 
nicht als Kommunikationsmedium mit einer eigenen Sprachgeschichte und Sprachgemeinschaft.\\

\noindent
Wir verwenden $L$ (ggf. mit unterschiedlichen Subskripten) als Variable für Sprachen;
wenn wir $L$ verwenden und nichts Anderslautendes angeben ist,
gilt implizit $L \subseteq \Sigma^*$ für ein gegebenes $\Sigma$.\\

\noindent
Da Sprachen Mengen sind,
sind alle mengentheoretischen Operationen\footnote{
    Für die wesentlichen Operationen für dieses Skript siehe: \autoref{mengenlehre}}
auf Sprachen definiert,
z.B. bezeichnet $L_1 \cap L_2 = \{w | w \in L_1 \wedge w \in L_2\}$
die Schnittmenge zweier Sprachen, also alle Wörter,
die sowohl Element von $L_1$ als auch von $L_2$ sind.



\subsection{Probleme als formale Sprachen}\label{subsec:problemeAlsFormaleSprachen}

\subsubsection{Einstellige Wahrheitsfunktionen}
Wie bekommen wir nun ein Problem, gegeben wie \textbf{I\textsubscript{EVEN}} 
(Gegeben: Eine Zahl / Gesucht: Ein Wahrheitswert, der anzeigt, ob die Zahl gerade ist)
in die Gestalt einer formalen Sprache?
Für \textbf{EVEN} ist dies recht unkompliziert:
Wir nutzen $\Sigma = \{0,1\}$ als Alphabet
und kodieren Zahlen mit Hilfe der folgenden (kanonischen) Binärrepresentation
$bin_{\mathbb{N}}: \mathbb{N} \rightarrow \Sigma^*$:
\[
    bin_{\mathbb{N}}(x) = a_{0}a_{1} \ldots a_{n}
\]
mit $x \in \mathbb{N}$ und $a_i \in \Sigma$ und 
\[
    x = \sum_{i=0}^n 2^{n-i} \cdot a_i
\]
\textbf{EVEN} ist dann die Menge aller binärkodierten geraden Zahlen, also:
\[
    \mathbf{EVEN} := \{0, 10, 100, 110, \ldots\}
\]
Analog könnten wir ein Problem \textbf{ODD} als formale Sprache kodieren:
\[
    \mathbf{ODD} := \{1, 11, 101, 111, \ldots \}
\]

Dies ist eine sehr einfache Lösung, um zu sehen,
wie man manche Probleme als formale Sprachen darstellen kann.
Ein Nachteil ist allerdings, dass diese Darstellung
nur für eine bestimmte Art von Problemen funktioniert,
nämlich solche, die man als einstellige Wahrheitsfunktionen beschreiben kann.


Eine Wahrheitsfunktion sei definiert als eine Funktion von einem beliebigen Definitionsbereich
in die Menge der Wahrheitswerte 0 und 1.\footnote{
    Hier haben wir natürlich die implizite Annahme getroffen,
    dass es zwei Wahrheitswerte ``gibt'' und nicht mehr (\emph{tertium non datur}).
    Das hat sowohl philosophische (siehe \cite{sep-logic-manyvalued}), als auch formale Implikationen (siehe \cite{gottwald}),
    die wir geneigten Leser:innen zur Kontemplation anempfehlen.
    Für unsere Einführung sind diese Erwägungen aber nebenrangig.
}
Eine einstellige Funktion hat einen eindimensionalen Definitionsbereich.
Die Summe zweier Zahlen $f_{SUM}: \mathbb{N} \times \mathbb{N} \rightarrow \mathbb{N}$
ist zum Beispiel weder eine Wahrheitsfunktion,
noch einstellig.
$f_{EVEN}: \mathbb{N} \rightarrow \{0,1\}$ dagegen ist beides.

Der Trick einstellige Wahrheitsfunktionen als formale Sprachen zu repräsentieren.
Für ein Wort $w$, das einen (einfachen) Wert $x$ kodiert,
gilt $w \in L_{PROBLEM}$, genau dann wenn $f_{PROBLEM}(x) = 1$.
Dieser Trick funktioniert nicht,
wenn $x$ komplex ist (d.h. $f_{PROBLEM}$ ist mehrstellig),
oder der Wertebereich aus mehr als zwei Werten besteht.

Da mit diesem Trick die formale Sprache $L_{EVEN}$ sehr elegant und platzsparend
\textbf{I\textsubscript{EVEN}} beziehungsfweise $f_{EVEN}$ kodiert,
werden wir diesen auch im weiteren Verlauf des Skriptes anwenden.

\subsubsection{Beliebige Funktionen}
Um beliebige Funktionen binär zu kodieren,
lohnt es sich noch einmal die genaue Definition einer Funktion anzuschauen:
Funktionen sind rechtseindeutige Relationen und Relationen sind Mengen von Tupeln mit identischer Länge (siehe \autoref{relationenUndFunktionen}).
Das bedeutet, zum Beispiel 
\[
    f_{EVEN} = \{ [0,1], [1,0], [2,1], [3,0], \ldots \}
\]

und
\[
    f_{SUM} = \{ [0,0,0], [1,0,1], [0,1,1], [1,1,2], \ldots \}
\]

Um beliebige Funktionen - und damit beliebige Probleme -
als formale Sprachen über $\Sigma = \{0,1\}$ zu kodieren,
suchen wir für jede Menge,
die Teil der Definitionsmenge oder Wertemenge einer Funktion sein kann,
eine Binärkodierung.
Für $\mathbb{N}$
haben wir bereits eine Kodierung ($bin_{\mathbb{N}}$) kennengelernt.
Für Elemente anderer Mengen gibt es zahlreiche Möglichkeiten,
aus denen man auswählen kann.\footnote{
    zum Beispiel \cite{ieee754} für $\mathbb{R}$,
    oder \cite{RFC3629} für beliebige Zeichen
}\\

\noindent
Sei nun $\cal{T}$ die Menge aller Tupel über $\{0,1\}$, also
\[
    \mathcal{T} = \{[0], [1], [0,0], [0,1], [1,0], [1,1], [0,0,0], \ldots \}
\]
Wir definieren zunächst die Hilfsfunktion $bin_{word}: \{0,1\}^* \rightarrow \{0,1\}^*$:
\[
    bin_{word}(w) = 0w_00w_1\ldots0w_n \text{ mit } |w| = n
\]
$bin_{word}$ fügt jedem Zeichen das Präfix 0 hinzu,
damit ``markieren'' wir alle Binärzeichen,
die tatsächlich ein Zeichen eines Elements eines Tupels kodieren.
Damit verdoppeln wir die Länge der Binärwörter, die element eines Tupels $t$ sind.
\[
    |bin_{word}(w)| = 2|w| 
\]
Gesucht ist nun noch eine Funktion $bin_{\mathcal{T}}: \mathcal{T} \rightarrow \{1,0\}^*$.
Sei $t \in \mathcal{T}$, dann bezeichnet $t_i$ genau das Binärwort an Position $i$.
Somit können wir $bin_{\mathcal{T}}$ definieren:
\[
    bin_{\mathcal{T}}(t) = bin_{word}(t_0)11bin_{word}(t_1)\ldots 11bin_{word}(t_{n})
\]
Z.B. ist $bin_{\mathcal{T}}([1,1,0]) = 0111011100$.
Da die Zeichenfolge 11 nicht Element der Wertemenge von $bin_{word}$ ist,
können wir so die Grenze der Binärwörter (die Kommata) im Tupel kodieren.
Damit haben wir eine generische Kodierung einer beliebigen Funktion
über $\Sigma = \{0,1\}$ angegeben.

Nach dieser Kodierung wäre also 
\[
    L_{EVEN} = \{001101, 011100, 01001101, 01011100, \ldots \}
\]
und
\[
    L_{SUM} = \{0011001100, 0111001101, 011101110100, \ldots \}
\]

\subsection{Warum formale Sprachen?}\label{subsec:warumFormaleSprachen}

Sind Probleme also formale Sprachen?
Die Antwort ist ein klares Nein.
Wir nutzen formale Sprachen, um Probleme zu kodieren,
aber formale Sprachen sind so wenig mit Problemen gleichzusetzen,
wie $\ldots$.
Konventionen und Interpretation und Übersetzung.

Die theoretische Informatik untersucht formale Sprachen auch als eigenen Gegenstand,
unabhängig davon, dass man formale Sprachen als formale Repräsentation von Problemen
interpretieren kann.

Macht es einen Unterschied, welche formale Sprache wir nutzen,
um ein Problem zu repräsentieren? Ja.
$L_{EVEN}$ und $EVEN$ und LittleEndian.

Was müssen alle Maschinen gemein haben, die $f_{EVEN}$ berechnen?
Wir müssen verlangen,
dass jede Maschine eine Eingabe und eine Ausgabe hat,
mit denen wir $n$ übergeben und den Wahrheitswert ablesen.
Wie müssten wir den Input und Output der Maschine gestalten,
d.h. in welche Form müssten wir das \textbf{EVEN}-Problem bringen,
dass die Maschine es lesen kann und wir den Output wieder verstehen können? 

Ein zugängliches Modell für den Input ist die Tastatur und der Bildschirm:
Eine endliche Menge von Zeichen (angezeigt durch Drücken der Knöpfe einer Tastatur)
werden von der Maschine übersetzt in eine Reaktion der Maschine 
(angezeigt durch die Pixel einer digitalen Ausgabe).
Tatsächlich werden die meisten Informationen,
die eine Maschine oder ein Computer verarbeiten,
intern in eine sehr kleine Menge an Zeichen übersetzt:
in Zeichenfolgen bestehend aus Nullen und Einsen.
Tastaturen und Bildschirme machen uns die Interaktion mit der Maschine einfacher,
allerdings sind sie für die Maschine selbst nicht nötig.

Ganz allgemein könnte man also sagen, dass alle Probleme, die ein Computer lösen soll,
sich in diese Form bringen lassen:
\begin{itemize}
    \item \textbf{Gegeben:} Eine binäre Zeichenfolge.
    \item \textbf{Gesucht:} Eine binäre Zeichenfolge.
\end{itemize}


Allerdings ist die binäre Repräsentation eine \emph{Konvention},
die durch die Realisierungen von Schaltungen in der technischen Informatik begründet ist.



Man könnte prinzipiell auf die Idee kommen Systeme zur Basis drei oder sogar minus zwei 
einzuführen.\footnote{
    Interessierte Leser:innen kommen in \cite{knuth2}, Chapter 4 (194-213) auf ihre Kosten.
}
Um die Bedingung der Unabhängigkeit von bestimmten Maschinen und Programmiersprachen zu erfüllen,





Wir haben im letzten Abschnitt die Binärkodierung \emph{kanonisch} genannt. 
Damit unterstreichen wir die praktische Bedeutung des binären Systems,
ohne von den möglichen Alternativen abzulenken.
Wir kommen im anschließenden Kapitel noch einmal auf die Bedeutung der Repräsentation
für die Komplexität eines Problems zurück.
Damit wir die dann gefundenen Methoden später von \textbf{EVEN}
auf andere Probleme übertragen können,
müssen wir zunächst noch einige Begriffe definieren und Konventionen einführen,
die von der kanonischen Repräsentation abstrahieren.

Die Sprache ist also der großen Tabelle nicht unähnlich,
in der man die ``richtigen'' $n$-Werte ablesen kann.
Wir wissen, dass diese Sprache unendlich viele Wörter hat und dass es unwirtschaftlich wäre
die Sprache wirklich aufzuschreiben (wir würden nie fertig werden).
Perspektivisch müssen wir also nach endlichen Methoden suchen,
(potentiell) unendliche Sprachen zu verarbeiten.

Sind nun Probleme identisch mit den formalen Sprachen, die sie repräsentieren? 
Die Antwort auf diese Frage hat sehr viele philosophische Implikationen.
Sprachphilosophisch könnten wir uns fragen,
ob die Übersetzung eines Problems in eine formale Sprache
überhaupt eindeutig und verlustfrei möglich ist.
Oder ob es überhaupt so etwas wie Probleme gibt, die von ihrer repräsentierten Sprache 
getrennt existieren.

Fakt ist zum einen, dass das \emph{Wortproblem}, also ob für ein Wort $w$ und eine Sprache $L$
gilt $w \in L$,
eng verknüpft ist mit einem abstrakten Problem, das von der formalen Sprache repräsentiert wird. 
Fakt ist ebenfalls, dass in vielen Textbüchern die formale Sprache und ihr Problem
im Prinzip miteinander austauschbare Entitäten sind. 
Wir wollen allerdings sorgsam sein und die beiden voneiander trennen.\\

\noindent
Um von unserer Userstory zu \textbf{EVEN} zu gelangen,
haben wir einen beträchtlichen formalen Aufwand investiert.
Daher stellt sich die Frage: Ist dieser Aufwand gerechtfertigt? 
Warum also geben wir Probleme als Wortprobleme von formalen Sprachen an?
Dies sind die wesentlichen Antworten auf beide Fragen,
nach Wichtigkeit aufsteigend sortiert:
\begin{itemize}
    \item Abstrakte Probleme mit Sprachen zu identifizieren gibt uns eine
        konzise, unmissverständliche Beschreibung von Problemen,
        die auch von Maschinen verarbeitet werden kann. 
    \item Die Abstraktion die in der Formalisierung wiedergespiegelt ist,
        ermöglicht sehr generelle Aussagekraft über das speziell betrachtete Problem hinweg.
    \item Aussagen über (effiziente) Berechenbarkeit werden mit den Methoden der Mathematik
        beweisbar, da wir u.a. die Ergebnisse der Mengenlehre, der Arithmetik
        und der Analysis anwenden können.
\end{itemize}


Zur ersten Frage stellen wir fest,
dass wir uns bei den gesuchten Aussagen nicht auf eine bestimmte Computer-Architektur
oder eine bestimmte Programmiersprache einlassen sollten:
Die Aussage, dass ein Problem \emph{un}berechenbar ist,
also, dass es keine Maschine gibt, die das Problem lösen kann,
wäre nicht abschließend lösbar:
es müsste für die unendliche Menge an Kombinationen von Hardware-Setups und Programmiersprachen
gezeigt werden.
Auch die Frage nach der Komplexität eines Problems wäre schwer zu erörtern:
Kann es nicht sein, dass das Problem auf dieser Hardware
und mit jener Programmiersprache nicht doch wesentlich effizienter zu lösen ist?
Wir wollen die Probleme also so abstrakt formalisieren,
dass unsere Aussagen über sie prinzipiell auf \emph{allen} Computerarchitekturen
und für \emph{alle} Programmiersprachen gültig sind.
Wir suchen also eine Formalisierung,
die von allen unwesentlichen Aspekten von Hardware und Programmierung abstrahiert.


Wir wollen Aussagen darüber treffen,
wie (leicht) eine beliebige Maschine ein gegebenes Problem lösen kann
und ob es überhaupt für Maschinen lösbar ist.
Desweiteren wollen wir nicht unbedingt nur etwas über einzelne Probleme erfahren,
sondern über Gruppen von Problemen und deren Beziehungen zueinander.
Diese beiden Aspekte erlauben es uns,
zwei Fragen in Bezug auf die Formalisierung zu stellen:
\begin{itemize}
\item Wie muss ein Problem formalisiert sein,
      dass wir Aussagen über das Problem unabhängig von einer konkreten Maschine treffen können?
\item Wie kann man den ``Raum'' beschreiben, in denen Probleme im Verhältnis zueinander stehen?
\end{itemize}


Die zweiten Frage - wie man den ``Raum'' der Probleme beschreiben kann -
bedingt ebenfalls eine abstrakte Repräsentation des Problems.
Nur so können wir das formale Handwerkszeug der Mengenlehre anwenden,
das uns eine konzise und formal einwandfreie Beschreibung dieses ``Raumes'' erlaubt.\footnote{
dann könnten wir auch die Anführungszeichen weglassen, weil wir uns dann einer formalen Definition des Raumes
bedienen könnten.}
%Die erste Möglichkeit bestünde darin,
%Probleme einfach als ``Atome'' aufzufassen,
%also als Einheiten ohne innere Struktur,
%auf denen wir dann Mengen bilden können.
%Es ist allerdings gerade die innere Struktur von Problemen,
%die zum Beispiel Abhängigkeiten zwischen Problemen klar werden lassen:
%Zum Beispiel könnte uns das Problem interessieren,
%ob eine Zahl durch 4 teilbar ist,
%also eine Abwandlung von \textbf{EVEN},
%bei dem es darum geht,
%ob eine Zahl durch 2 teilbar ist.
%Geben wir diesem Problem dem Namen \textbf{DIV4},
%dann ist klar, dass \textbf{DIV4} irgendwie mit \textbf{EVEN} zusammenhängt,
%denn eine Zahl, die durch 4 teilbar ist, ist auch immer durch 2 teilbar -
%allerdings nicht andersherum.
Um Zusammenhänge zwischen Problemen untersuchbar zu machen,
müssen wir auch einen Blick in ihre innere Struktur werfen.

Gesucht ist also eine grundlegende Art, Probleme zu formalisieren, mit den folgenden Bedingungen:
\begin{enumerate}
 \item Unabhängig von einer bestimmten Maschine oder Programmiersprache
 \item Mengentheoretische Behandlung von Problemen
 \item Analysemöglichkeit der inneren Struktur von Problemen
\end{enumerate}

Wir werden sehen, dass eine Repräsentation von Problemen als formale Sprachen genau diese Bedingungen erfüllen.

Zusammenfassend können wir feststellen:
\begin{itemize}
    \item Abstraktion und Formalisierung.
    \item Probleme lassen sich als Sprachen repräsentieren.
        Ist es lösbar, ob ein Wort zu einer Sprache gehört,
        ist auch das repräsentierte Problem lösbar. 
    \item Die abstrakten Probleme der theoretischen Informatik lassen sich mit
        mathematischen Werkzeugen bearbeiten,
        wodurch ihre Ergebnisse theoretisch gefestigt sind 
        und die Aussagekraft sehr generell ist.
\end{itemize}
